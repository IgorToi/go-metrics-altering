
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>memory: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/igortoigildin/go-metrics-altering/internal/agent/memory/memory.go (94.7%)</option>
				
				<option value="file1">github.com/igortoigildin/go-metrics-altering/internal/agent/sendMetrics/sendJSONMetric.go (71.8%)</option>
				
				<option value="file2">github.com/igortoigildin/go-metrics-altering/internal/agent/sendMetrics/sendURLMetric.go (73.5%)</option>
				
				<option value="file3">github.com/igortoigildin/go-metrics-altering/internal/server/grpc/rpcserver/server.go (66.7%)</option>
				
				<option value="file4">github.com/igortoigildin/go-metrics-altering/internal/server/http/api/handlers.go (88.6%)</option>
				
				<option value="file5">github.com/igortoigildin/go-metrics-altering/internal/server/http/api/mocks/Storage.go (74.0%)</option>
				
				<option value="file6">github.com/igortoigildin/go-metrics-altering/internal/server/http/api/router.go (100.0%)</option>
				
				<option value="file7">github.com/igortoigildin/go-metrics-altering/internal/storage/inmemory/local.go (83.1%)</option>
				
				<option value="file8">github.com/igortoigildin/go-metrics-altering/internal/storage/inmemory/setMetricAlgo.go (92.9%)</option>
				
				<option value="file9">github.com/igortoigildin/go-metrics-altering/internal/storage/postgres/postgres.go (60.8%)</option>
				
				<option value="file10">github.com/igortoigildin/go-metrics-altering/internal/storage/postgres/strategy.go (50.0%)</option>
				
				<option value="file11">github.com/igortoigildin/go-metrics-altering/pkg/crypt/decrypt.go (75.0%)</option>
				
				<option value="file12">github.com/igortoigildin/go-metrics-altering/pkg/crypt/encrypt.go (75.0%)</option>
				
				<option value="file13">github.com/igortoigildin/go-metrics-altering/pkg/crypt/savekey.go (75.0%)</option>
				
				<option value="file14">github.com/igortoigildin/go-metrics-altering/pkg/httpServer/options.go (50.0%)</option>
				
				<option value="file15">github.com/igortoigildin/go-metrics-altering/pkg/httpServer/server.go (84.6%)</option>
				
				<option value="file16">github.com/igortoigildin/go-metrics-altering/pkg/interceptors/logging/adapter.go (81.0%)</option>
				
				<option value="file17">github.com/igortoigildin/go-metrics-altering/pkg/logger/logger.go (90.0%)</option>
				
				<option value="file18">github.com/igortoigildin/go-metrics-altering/pkg/middlewares/auth/auth.go (44.4%)</option>
				
				<option value="file19">github.com/igortoigildin/go-metrics-altering/pkg/middlewares/compress/compress.go (78.8%)</option>
				
				<option value="file20">github.com/igortoigildin/go-metrics-altering/pkg/middlewares/logging/logger.go (100.0%)</option>
				
				<option value="file21">github.com/igortoigildin/go-metrics-altering/pkg/middlewares/timeout/timeout.go (8.3%)</option>
				
				<option value="file22">github.com/igortoigildin/go-metrics-altering/pkg/processJSON/processJSON.go (78.6%)</option>
				
				<option value="file23">github.com/igortoigildin/go-metrics-altering/pkg/processMap/processMap.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package memory accumulates updated metrics,
// which is being used and consumed by agent.

package memory

import (
        "errors"
        "math/rand/v2"
        "runtime"
        "sync"

        config "github.com/igortoigildin/go-metrics-altering/config/agent"
        "github.com/igortoigildin/go-metrics-altering/internal/models"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
        "github.com/shirou/gopsutil/cpu"
        "github.com/shirou/gopsutil/mem"
        "go.uber.org/zap"
)

var (
        ErrConnectionFailed = errors.New("connection failed")
)

// MemoryStats provides temporary storage for collected metrics.
type MemoryStats struct {
        GaugeMetrics  map[string]float64
        CounterMetric int
        RunTimeMem    *runtime.MemStats
        rwm           sync.RWMutex
}

// NewMemoryStats is constructor for MemoryStats.
func New() *MemoryStats <span class="cov8" title="1">{
        return &amp;MemoryStats{
                GaugeMetrics: make(map[string]float64),
                RunTimeMem:   &amp;runtime.MemStats{},
        }
}</span>

// ReadMetrics collects runtime metrics from memory and sends it to agent via metricsChan.
func (m *MemoryStats) ReadMetrics(cfg *config.ConfigAgent, metricsChan chan models.Metrics) <span class="cov8" title="1">{
        m.rwm.Lock()
        for name, value := range m.GaugeMetrics </span><span class="cov8" title="1">{
                metric := models.GaugeConstructor(value, name)
                metricsChan &lt;- metric
        }</span>
        <span class="cov8" title="1">m.rwm.Unlock()
        metric := models.CounterConstructor(int64(m.CounterMetric))
        metricsChan &lt;- metric</span>
}

// UpdateCPURAMStat collects and updates in MemoryStats CPU metrics.
func (m *MemoryStats) UpdateCPURAMStat(cfg *config.ConfigAgent) <span class="cov8" title="1">{
        if m.GaugeMetrics == nil </span><span class="cov0" title="0">{
                m.GaugeMetrics = make(map[string]float64, 3)
        }</span>

        <span class="cov8" title="1">cpuNumber, err := cpu.Counts(true)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error while loading cpu Counts:", zap.Error(err))
        }</span>
        <span class="cov8" title="1">v, err := mem.VirtualMemory()
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error while loading virtualmemoryStat:", zap.Error(err))
        }</span>
        <span class="cov8" title="1">m.rwm.Lock()
        m.GaugeMetrics["TotalMemory"] = float64(v.Total)
        m.GaugeMetrics["FreeMemory"] = float64(v.Free)
        m.GaugeMetrics["CPUutilization1"] = float64(cpuNumber)
        m.rwm.Unlock()</span>
}

// UpdateRunTimeStat collects and updates in MemoryStats runtime metrics.
func (m *MemoryStats) UpdateRunTimeStat(cfg *config.ConfigAgent) <span class="cov8" title="1">{
        runtime.ReadMemStats(m.RunTimeMem)
        m.rwm.Lock()
        m.GaugeMetrics["Alloc"] = float64(m.RunTimeMem.Alloc)
        m.GaugeMetrics["BuckHashSys"] = float64(m.RunTimeMem.BuckHashSys)
        m.GaugeMetrics["Frees"] = float64(m.RunTimeMem.Frees)
        m.GaugeMetrics["GCCPUFraction"] = float64(m.RunTimeMem.GCCPUFraction)
        m.GaugeMetrics["GCSys"] = float64(m.RunTimeMem.GCSys)
        m.GaugeMetrics["HeapAlloc"] = float64(m.RunTimeMem.HeapAlloc)
        m.GaugeMetrics["HeapIdle"] = float64(m.RunTimeMem.HeapIdle)
        m.GaugeMetrics["HeapInuse"] = float64(m.RunTimeMem.HeapInuse)
        m.GaugeMetrics["HeapObjects"] = float64(m.RunTimeMem.HeapObjects)
        m.GaugeMetrics["HeapReleased"] = float64(m.RunTimeMem.HeapReleased)
        m.GaugeMetrics["HeapSys"] = float64(m.RunTimeMem.HeapSys)
        m.GaugeMetrics["LastGC"] = float64(m.RunTimeMem.LastGC)
        m.GaugeMetrics["Lookups"] = float64(m.RunTimeMem.Lookups)
        m.GaugeMetrics["MCacheInuse"] = float64(m.RunTimeMem.MCacheInuse)
        m.GaugeMetrics["MCacheSys"] = float64(m.RunTimeMem.MCacheSys)
        m.GaugeMetrics["MSpanInuse"] = float64(m.RunTimeMem.MSpanInuse)
        m.GaugeMetrics["MSpanSys"] = float64(m.RunTimeMem.MSpanSys)
        m.GaugeMetrics["Mallocs"] = float64(m.RunTimeMem.Mallocs)
        m.GaugeMetrics["NextGC"] = float64(m.RunTimeMem.NextGC)
        m.GaugeMetrics["NumForcedGC"] = float64(m.RunTimeMem.NumForcedGC)
        m.GaugeMetrics["NumGC"] = float64(m.RunTimeMem.NumGC)
        m.GaugeMetrics["OtherSys"] = float64(m.RunTimeMem.OtherSys)
        m.GaugeMetrics["NextGC"] = float64(m.RunTimeMem.NextGC)
        m.GaugeMetrics["NumForcedGC"] = float64(m.RunTimeMem.NumForcedGC)
        m.GaugeMetrics["NumGC"] = float64(m.RunTimeMem.NumGC)
        m.GaugeMetrics["OtherSys"] = float64(m.RunTimeMem.OtherSys)
        m.GaugeMetrics["PauseTotalNs"] = float64(m.RunTimeMem.PauseTotalNs)
        m.GaugeMetrics["StackInuse"] = float64(m.RunTimeMem.StackInuse)
        m.GaugeMetrics["StackSys"] = float64(m.RunTimeMem.StackSys)
        m.GaugeMetrics["Sys"] = float64(m.RunTimeMem.StackSys)
        m.GaugeMetrics["TotalAlloc"] = float64(m.RunTimeMem.TotalAlloc)
        m.GaugeMetrics["RandomValue"] = rand.Float64()
        m.CounterMetric++
        m.rwm.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package sendmetrics

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "time"

        "github.com/go-resty/resty/v2"
        config "github.com/igortoigildin/go-metrics-altering/config/agent"
        "github.com/igortoigildin/go-metrics-altering/internal/models"
        "github.com/igortoigildin/go-metrics-altering/pkg/crypt"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
        "go.uber.org/zap"
)

const updEndpoint = "/update/"

var (
        ErrConnectionFailed = errors.New("connection failed")
)

// SendJSONGauge accepts and sends gauge metrics in JSON format to predefined by config server address.
func SendJSONGauge(metricName string, cfg *config.ConfigAgent, value float64) error <span class="cov8" title="1">{
        agent := resty.New()

        if metricName == "" </span><span class="cov8" title="1">{
                logger.Log.Info("metric data not complete")
                return errors.New("metric data not complete")
        }</span>

        <span class="cov8" title="1">metric := models.GaugeConstructor(value, metricName)
        req := agent.R().SetHeader("Content-Type", "application/json")

        // Add X-Real-IP header as defined by agent config
        req.SetHeader("X-Real-IP", cfg.FlagRealIP)

        metricsJSON, err := json.Marshal(metric)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("marshalling json error:", zap.Error(err))
                return err
        }</span>

        // signing metric value with sha256 and setting header accordingly
        <span class="cov8" title="1">if cfg.FlagHashKey != "" </span><span class="cov8" title="1">{
                key := []byte(cfg.FlagHashKey)
                h := hmac.New(sha256.New, key)
                h.Write(metricsJSON)
                dst := h.Sum(nil)
                req.SetHeader("HashSHA256", fmt.Sprintf("%x", dst))
        }</span>

        <span class="cov8" title="1">if cfg.FlagRSAEncryption </span><span class="cov8" title="1">{
                publicKeyPEM, err := os.ReadFile(cfg.FlagCryptoKey)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error while reading rsa public key:", zap.Error(err))
                }</span>

                // encrypting using public key
                <span class="cov8" title="1">metricsJSON, err = crypt.Encrypt(publicKeyPEM, metricsJSON)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error while encrypting data")
                }</span>
        }

        <span class="cov8" title="1">_, err = req.SetBody(metricsJSON).Post(cfg.URL + updEndpoint)
        if err != nil </span><span class="cov8" title="1">{
                // send again n times if timeout error
                switch </span>{
                case os.IsTimeout(err):<span class="cov0" title="0">
                        for _, delay := range []time.Duration{time.Second, 2 * time.Second, 3 * time.Second} </span><span class="cov0" title="0">{
                                time.Sleep(delay)
                                if _, err = req.Post(req.URL); err == nil </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">return ErrConnectionFailed</span>
                default:<span class="cov8" title="1">
                        logger.Log.Info("unexpected sending metric error:", zap.Error(err))
                        return err</span>
                }
        }

        <span class="cov8" title="1">logger.Log.Info("sent JSON gauge metric:", zap.Float64(metricName, value))
        return nil</span>
}

// SendJSONCounter accepts and sends gauge metrics in JSON format to predefined by config server address.
func SendJSONCounter(counter int, cfg *config.ConfigAgent) error <span class="cov8" title="1">{
        agent := resty.New()

        metric := models.CounterConstructor(int64(counter))
        req := agent.R().SetHeader("Content-Type", "application/json")

        // Add X-Real-IP header as defined by agent config
        req.SetHeader("X-Real-IP", cfg.FlagRealIP)

        metricJSON, err := json.Marshal(metric)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("marshalling json error:", zap.Error(err))
                return err
        }</span>
        // signing metric value with sha256 and setting header accordingly
        <span class="cov8" title="1">if cfg.FlagHashKey != "" </span><span class="cov8" title="1">{
                key := []byte(cfg.FlagHashKey)
                h := hmac.New(sha256.New, key)
                h.Write(metricJSON)
                dst := h.Sum(nil)
                req.SetHeader("HashSHA256", fmt.Sprintf("%x", dst))
        }</span>

        <span class="cov8" title="1">if cfg.FlagRSAEncryption </span><span class="cov8" title="1">{
                publicKeyPEM, err := os.ReadFile(cfg.FlagCryptoKey)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error while reading rsa public key:", zap.Error(err))
                        return err
                }</span>
                // encrypting using public key
                <span class="cov8" title="1">metricJSON, err = crypt.Encrypt(publicKeyPEM, metricJSON)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error while encrypting data")
                        return err
                }</span>
        }

        <span class="cov8" title="1">_, err = req.SetBody(metricJSON).Post(cfg.URL + updEndpoint)
        if err != nil </span><span class="cov8" title="1">{
                // send again n times if timeout error
                switch </span>{
                case os.IsTimeout(err):<span class="cov0" title="0">
                        for _, delay := range []time.Duration{time.Second, 2 * time.Second, 3 * time.Second} </span><span class="cov0" title="0">{
                                time.Sleep(delay)
                                if _, err = req.Post(req.URL); err == nil </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">return ErrConnectionFailed</span>
                default:<span class="cov8" title="1">
                        logger.Log.Info("unexpected sending metric error:", zap.Error(err))
                        return err</span>
                }
        }

        <span class="cov8" title="1">logger.Log.Info("sent JSON counter metric:", zap.Int("conuter", counter))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package sendmetrics

import (
        "crypto/hmac"
        "crypto/sha256"
        "fmt"
        "net/http"
        "os"
        "strconv"
        "time"

        config "github.com/igortoigildin/go-metrics-altering/config/agent"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
        "go.uber.org/zap"
)

// SendJSONCounter accepts and sends counter metrics in URL format to predefined by config server address.
func SendURLCounter(cfg *config.ConfigAgent, counter int) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/update/%s/%s/%s", config.GaugeType, config.PollCount, strconv.Itoa(counter))
        r, err := http.NewRequest("POST", cfg.URL+path, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error while preparing http request", zap.Error(err))
        }</span>

        // signing metric value with sha256 and setting header accordingly
        <span class="cov8" title="1">if cfg.FlagHashKey != "" </span><span class="cov8" title="1">{
                key := []byte(cfg.FlagHashKey)
                h := hmac.New(sha256.New, key)
                h.Write(nil)
                dst := h.Sum(nil)
                r.Header = http.Header{
                        "HashSHA256": {fmt.Sprintf("%x", dst)},
                }
        }</span>

        // Add X-Real-IP header as defined by agent config
        <span class="cov8" title="1">r.Header.Add("X-Real-IP", cfg.FlagRealIP)

        client := http.Client{}
        _, err = client.Do(r)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case os.IsTimeout(err):<span class="cov0" title="0">
                        for _, delay := range []time.Duration{time.Second, 2 * time.Second, 3 * time.Second} </span><span class="cov0" title="0">{
                                time.Sleep(delay)
                                if _, err = client.Do(r); err == nil </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">return ErrConnectionFailed</span>
                default:<span class="cov8" title="1">
                        return err</span>
                }
        }

        <span class="cov8" title="1">logger.Log.Info("sent url counter metric:", zap.Int("conuter", counter))
        return nil</span>
}

// SendURLGauge accepts and sends gauge metrics in URL format to predefined by config server address.
func SendURLGauge(cfg *config.ConfigAgent, value float64, metricName string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/update/%s/%s/%s", config.GaugeType, metricName, strconv.FormatFloat(value, 'f', 6, 64))
        r, err := http.NewRequest("POST", cfg.URL+path, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error while preparing http request", zap.Error(err))
        }</span>

        // signing metric value with sha256 and setting header accordingly
        <span class="cov8" title="1">if cfg.FlagHashKey != "" </span><span class="cov8" title="1">{
                key := []byte(cfg.FlagHashKey)
                h := hmac.New(sha256.New, key)
                h.Write(nil)
                dst := h.Sum(nil)
                r.Header = http.Header{
                        "HashSHA256": {fmt.Sprintf("%x", dst)},
                }
        }</span>

        // Add X-Real-IP header as defined by agent config
        <span class="cov8" title="1">r.Header.Add("X-Real-IP", cfg.FlagRealIP)

        client := http.Client{}

        _, err = client.Do(r)

        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case os.IsTimeout(err):<span class="cov0" title="0">
                        err := retryURL(client, r)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        }

        <span class="cov8" title="1">logger.Log.Info("sent url gauge metric:", zap.Float64(metricName, value))
        return nil</span>
}

func retryURL(client http.Client, r *http.Request) error <span class="cov8" title="1">{
        for _, delay := range []time.Duration{time.Second, 2 * time.Second, 3 * time.Second} </span><span class="cov8" title="1">{
                time.Sleep(delay)
                if _, err := client.Do(r); err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return ErrConnectionFailed</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package metricsgrpc

import (
        "context"

        "github.com/igortoigildin/go-metrics-altering/internal/models"
        metrics "github.com/igortoigildin/go-metrics-altering/pkg/metrics_v1"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

const (
        gauge   = "gauge"
        counter = "counter"
)

//go:generate go run github.com/vektra/mockery/v2@v2.45.0 --name=Storage
type Storage interface {
        Update(ctx context.Context, metricType string, metricName string, metricValue any) error
        Get(ctx context.Context, metricType string, metricName string) (models.Metrics, error)
        GetAll(ctx context.Context) (map[string]any, error)
        Ping(ctx context.Context) error
}

type ServerAPI struct {
        metrics.UnimplementedMetricsServer
        Storage Storage
}

func Register(gRPC *grpc.Server, storage Storage) <span class="cov0" title="0">{
        metrics.RegisterMetricsServer(gRPC, &amp;ServerAPI{Storage: storage})
}</span>

func (s *ServerAPI) AddGaugeMetric(ctx context.Context, req *metrics.AddGaugeRequest) (*metrics.AddGaugeResponse, error) <span class="cov8" title="1">{
        err := s.Storage.Update(ctx, gauge, req.Metric.Name, req.Metric.Value)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "internal error")
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

func (s *ServerAPI) AddCounterMetric(ctx context.Context, req *metrics.AddCounterRequest) (*metrics.AddCounterResponse, error) <span class="cov8" title="1">{
        err := s.Storage.Update(ctx, counter, req.Metric.Name, req.Metric.Value)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, "internal error")
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "io"
        "net/http"
        "os"
        "strconv"

        _ "net/http/pprof" // подключаем пакет pprof

        config "github.com/igortoigildin/go-metrics-altering/config/server"
        "github.com/igortoigildin/go-metrics-altering/internal/models"
        "github.com/igortoigildin/go-metrics-altering/pkg/crypt"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
        processjson "github.com/igortoigildin/go-metrics-altering/pkg/processJSON"
        "go.uber.org/zap"
)

const (
        path = "keys/private.pem"
)

//go:generate go run github.com/vektra/mockery/v2@v2.45.0 --name=Storage
type Storage interface {
        Update(ctx context.Context, metricType string, metricName string, metricValue any) error
        Get(ctx context.Context, metricType string, metricName string) (models.Metrics, error)
        GetAll(ctx context.Context) (map[string]any, error)
        Ping(ctx context.Context) error
}

func ping(Storage Storage) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ctx := r.Context()
                if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                        logger.Log.Info("got request with bad method", zap.String("method", r.Method))
                        w.WriteHeader(http.StatusMethodNotAllowed)
                        return
                }</span>
                <span class="cov8" title="1">err := Storage.Ping(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
        })
}

func updates(Storage Storage) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ctx := r.Context()

                if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                        logger.Log.Info("got request with bad method", zap.String("method", r.Method))
                        w.WriteHeader(http.StatusMethodNotAllowed)
                        return
                }</span>

                <span class="cov8" title="1">metrics := make([]models.Metrics, 0)
                err := processjson.ReadJSON(r, &amp;metrics)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("cannot decode request JSON body", zap.Error(err))
                        w.WriteHeader(http.StatusBadRequest)
                        return
                }</span>

                // iterating through []Metrics and adding it to db one by one
                <span class="cov8" title="1">for _, metric := range metrics </span><span class="cov8" title="1">{
                        if metric.MType != config.GaugeType &amp;&amp; metric.MType != config.CountType </span><span class="cov8" title="1">{
                                logger.Log.Info("usupported request type", zap.String("type", metric.MType))
                                w.WriteHeader(http.StatusUnprocessableEntity)
                                return
                        }</span>
                        <span class="cov8" title="1">switch metric.MType </span>{
                        case config.GaugeType:<span class="cov8" title="1">
                                err := Storage.Update(ctx, metric.MType, metric.ID, metric.Value)
                                if err != nil </span><span class="cov8" title="1">{
                                        logger.Log.Info("error while updating value", zap.Error(err))
                                        w.WriteHeader(http.StatusInternalServerError)
                                        return
                                }</span>
                        case config.CountType:<span class="cov8" title="1">
                                err := Storage.Update(ctx, metric.MType, metric.ID, metric.Delta)
                                if err != nil </span><span class="cov8" title="1">{
                                        logger.Log.Info("error while updating value", zap.Error(err))
                                        w.WriteHeader(http.StatusInternalServerError)
                                        return
                                }</span>
                        }
                }
                <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")</span>
        })
}

func updateMetric(Storage Storage) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{

                ctx := r.Context()

                if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                        logger.Log.Info("got request with bad method", zap.String("method", r.Method))
                        w.WriteHeader(http.StatusMethodNotAllowed)
                        return
                }</span>

                //obtaining private key from file
                <span class="cov8" title="1">privateKeyPEM, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error while reading key", zap.Error(err))
                        return
                }</span>

                <span class="cov8" title="1">body, err := io.ReadAll(r.Body)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Error reading request body", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">defer r.Body.Close()

                // decrypting request body using private key
                plaintext, err := crypt.Decrypt(privateKeyPEM, body)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error while decryping data")
                        return
                }</span>

                <span class="cov8" title="1">var req models.Metrics

                err = json.Unmarshal(plaintext, &amp;req)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error: ", zap.Error(err))
                }</span>

                <span class="cov8" title="1">switch req.MType </span>{
                case config.GaugeType:<span class="cov8" title="1">
                        err := Storage.Update(ctx, req.MType, req.ID, req.Value)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Log.Info("error while updating value", zap.Error(err))
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                case config.CountType:<span class="cov8" title="1">
                        err := Storage.Update(ctx, req.MType, req.ID, req.Delta)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Log.Info("error while updating value", zap.Error(err))
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                default:<span class="cov8" title="1">
                        logger.Log.Info("usupported request type", zap.String("type", req.MType))
                        w.WriteHeader(http.StatusUnprocessableEntity)
                        return</span>
                }

                <span class="cov8" title="1">resp := models.Metrics{
                        ID:    req.ID,
                        MType: req.MType,
                        Value: req.Value,
                        Delta: req.Delta,
                }
                err = processjson.WriteJSON(w, http.StatusOK, resp, nil)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error encoding response", zap.Error(err))
                        return
                }</span>
        })
}

func getAllmetrics(Storage Storage) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Content-Type", "text/html; charset=utf-8")
                w.Header().Add("Content-Encoding", "gzip")
                metrics, err := Storage.GetAll(r.Context())
                if err != nil </span><span class="cov8" title="1">{
                        logger.Log.Info("error", zap.Error(err))
                        w.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">err = processjson.WriteJSON(w, http.StatusOK, metrics, nil)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error encoding response", zap.Error(err))
                        return
                }</span>
        })
}

func getMetric(Storage Storage) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ctx := r.Context()

                if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                        logger.Log.Info("got request with bad method", zap.String("method", r.Method))
                        w.WriteHeader(http.StatusMethodNotAllowed)
                        return
                }</span>

                <span class="cov8" title="1">var req models.Metrics
                err := processjson.ReadJSON(r, &amp;req)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("cannot decode request JSON body", zap.Error(err))
                        w.WriteHeader(http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">if req.MType != config.GaugeType &amp;&amp; req.MType != config.CountType </span><span class="cov8" title="1">{
                        logger.Log.Info("usupported request type", zap.String("type", req.MType))
                        w.WriteHeader(http.StatusUnprocessableEntity)
                        return
                }</span>

                <span class="cov8" title="1">resp := models.Metrics{
                        ID:    req.ID,
                        MType: req.MType,
                }

                switch req.MType </span>{
                case config.GaugeType:<span class="cov8" title="1">
                        res, err := Storage.Get(ctx, req.MType, req.ID)
                        if err != nil </span><span class="cov8" title="1">{
                                switch </span>{
                                case errors.Is(err, sql.ErrNoRows):<span class="cov8" title="1">
                                        logger.Log.Info("error while obtaining metric", zap.Error(err))
                                        w.WriteHeader(http.StatusNotFound)
                                        return</span>
                                default:<span class="cov8" title="1">
                                        logger.Log.Info("error while obtaining metric", zap.Error(err))
                                        w.WriteHeader(http.StatusInternalServerError)
                                        return</span>
                                }
                        }
                        <span class="cov8" title="1">resp.Value = res.Value</span>
                case config.CountType:<span class="cov8" title="1">
                        res, err := Storage.Get(ctx, req.MType, req.ID)
                        if err != nil </span><span class="cov8" title="1">{
                                switch </span>{
                                case errors.Is(err, sql.ErrNoRows):<span class="cov8" title="1">
                                        logger.Log.Info("error while obtaining metric", zap.Error(err))
                                        w.WriteHeader(http.StatusNotFound)
                                        return</span>
                                default:<span class="cov8" title="1">
                                        logger.Log.Info("error while obtaining metric", zap.Error(err))
                                        w.WriteHeader(http.StatusInternalServerError)
                                        return</span>
                                }
                        }
                        <span class="cov8" title="1">resp.Delta = res.Delta</span>
                }

                <span class="cov8" title="1">w.Header().Add("Content-Encoding", "gzip")
                err = processjson.WriteJSON(w, http.StatusOK, resp, nil)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error encoding response", zap.Error(err))
                        return
                }</span>
        })
}

func updatePathHandler(LocalStorage Storage) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                metricType := r.PathValue("metricType")
                metricName := r.PathValue("metricName")
                metricValue := r.PathValue("metricValue")

                switch metricType </span>{
                case config.GaugeType:<span class="cov8" title="1">
                        metricValueConverted, err := strconv.ParseFloat(metricValue, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Log.Error("error parsing metric value to float", zap.Error(err))
                                w.WriteHeader(http.StatusBadRequest)
                                return
                        }</span>

                        <span class="cov8" title="1">err = LocalStorage.Update(context.TODO(), config.GaugeType, metricName, metricValueConverted)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Log.Error("error while updating metric", zap.Error(err))
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>

                case config.CountType:<span class="cov8" title="1">
                        metricValueConverted, err := strconv.ParseInt(metricValue, 10, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Log.Error("error parsing metric value to int", zap.Error(err))
                                w.WriteHeader(http.StatusBadRequest)
                                return
                        }</span>

                        <span class="cov8" title="1">err = LocalStorage.Update(context.TODO(), config.CountType, metricName, metricValueConverted)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Log.Error("error while updating metric", zap.Error(err))
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                default:<span class="cov8" title="1">
                        w.WriteHeader(http.StatusBadRequest)
                        return</span>
                }
                <span class="cov8" title="1">w.Header().Set("Content-Type", "text/plain; charset=utf-8")</span>
        })
}

func valuePathHandler(LocalStorage Storage) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{

                metricType := r.PathValue("metricType")
                metricName := r.PathValue("metricName")

                switch metricType </span>{
                case config.GaugeType:<span class="cov8" title="1">
                        metric, err := LocalStorage.Get(context.TODO(), config.GaugeType, metricName)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Log.Error("error while loading metric", zap.Error(err))
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov8" title="1">w.Write([]byte(strconv.FormatFloat(*metric.Value, 'f', -1, 64)))</span>
                case config.CountType:<span class="cov8" title="1">
                        metric, err := LocalStorage.Get(context.TODO(), config.CountType, config.PollCount)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Log.Error("error while loading metric", zap.Error(err))
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov8" title="1">w.Write([]byte(strconv.FormatInt(*metric.Delta, 10)))</span>
                default:<span class="cov8" title="1">
                        logger.Log.Info("usupported request type", zap.String("type", metricType))
                        w.WriteHeader(http.StatusUnprocessableEntity)
                        return</span>
                }
        })
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by mockery v2.45.0. DO NOT EDIT.

package mocks

import (
        context "context"

        models "github.com/igortoigildin/go-metrics-altering/internal/models"
        mock "github.com/stretchr/testify/mock"
)

// Storage is an autogenerated mock type for the Storage type
type Storage struct {
        mock.Mock
}

// Get provides a mock function with given fields: ctx, metricType, metricName
func (_m *Storage) Get(ctx context.Context, metricType string, metricName string) (models.Metrics, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, metricType, metricName)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Get")</span>
        }

        <span class="cov8" title="1">var r0 models.Metrics
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (models.Metrics, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, metricType, metricName)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string, string) models.Metrics); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, metricType, metricName)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(models.Metrics)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, metricType, metricName)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetAll provides a mock function with given fields: ctx
func (_m *Storage) GetAll(ctx context.Context) (map[string]interface{}, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAll")</span>
        }

        <span class="cov8" title="1">var r0 map[string]interface{}
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) (map[string]interface{}, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context) map[string]interface{}); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(map[string]interface{})
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// Ping provides a mock function with given fields: ctx
func (_m *Storage) Ping(ctx context.Context) error <span class="cov8" title="1">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Ping")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// Update provides a mock function with given fields: ctx, metricType, metricName, metricValue
func (_m *Storage) Update(ctx context.Context, metricType string, metricName string, metricValue interface{}) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, metricType, metricName, metricValue)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Update")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, metricType, metricName, metricValue)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// NewStorage creates a new instance of Storage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewStorage(t interface {
        mock.TestingT
        Cleanup(func())
}) *Storage <span class="cov8" title="1">{
        mock := &amp;Storage{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "context"
        "net/http"
        "text/template"

        config "github.com/igortoigildin/go-metrics-altering/config/server"
        "github.com/igortoigildin/go-metrics-altering/pkg/middlewares/auth"
        "github.com/igortoigildin/go-metrics-altering/pkg/middlewares/compress"
        "github.com/igortoigildin/go-metrics-altering/pkg/middlewares/logging"
        "github.com/igortoigildin/go-metrics-altering/pkg/middlewares/timeout"
        "github.com/igortoigildin/go-metrics-altering/templates"
)

var t *template.Template

func Router(ctx context.Context, cfg *config.ConfigServer, storage Storage) *http.ServeMux <span class="cov8" title="1">{
        t = templates.ParseTemplate()

        mux := http.NewServeMux()
        mux.HandleFunc("GET /value/{metricType}/{metricName}", logging.WithLogging(compress.GzipMiddleware((auth.Auth(http.HandlerFunc(valuePathHandler(storage)), cfg)))))
        mux.HandleFunc("POST /update/{metricType}/{metricName}/{metricValue}", logging.WithLogging(compress.GzipMiddleware(auth.Auth(http.HandlerFunc(updatePathHandler(storage)), cfg))))
        mux.HandleFunc("GET /ping", timeout.Timeout(cfg.ContextTimout, logging.WithLogging(compress.GzipMiddleware(auth.Auth(http.HandlerFunc(ping(storage)), cfg)))))
        mux.HandleFunc("GET /", timeout.Timeout(cfg.ContextTimout, logging.WithLogging(compress.GzipMiddleware(auth.Auth(http.HandlerFunc(getAllmetrics(storage)), cfg)))))
        mux.HandleFunc("POST /updates/", timeout.Timeout(cfg.ContextTimout, logging.WithLogging(compress.GzipMiddleware(auth.Auth(http.HandlerFunc(updates(storage)), cfg)))))
        mux.HandleFunc("POST /value/", timeout.Timeout(cfg.ContextTimout, logging.WithLogging(compress.GzipMiddleware(auth.Auth(http.HandlerFunc(getMetric(storage)), cfg)))))
        mux.HandleFunc("POST /update/", timeout.Timeout(cfg.ContextTimout, logging.WithLogging(compress.GzipMiddleware(auth.Auth(http.HandlerFunc(updateMetric(storage)), cfg)))))

        return mux
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package local storage implementation for inmemory Storage interface.
package local

import (
        "context"
        "encoding/json"
        "errors"
        "os"
        "sync"

        config "github.com/igortoigildin/go-metrics-altering/config/agent"
        "github.com/igortoigildin/go-metrics-altering/internal/models"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
        processmap "github.com/igortoigildin/go-metrics-altering/pkg/processMap"
        "go.uber.org/zap"
)

const pollCount = "PollCount"

type LocalStorage struct {
        rm       sync.RWMutex
        Gauge    map[string]float64
        Counter  map[string]int64
        strategy MetricAlgo
}

func New() *LocalStorage <span class="cov8" title="1">{
        return &amp;LocalStorage{
                Counter: map[string]int64{pollCount: 0},
                Gauge:   map[string]float64{},
        }
}</span>

func (m *LocalStorage) setMetricAlgo(metricType string) <span class="cov8" title="1">{
        if metricType == config.CountType </span><span class="cov8" title="1">{
                count := counterRepo{
                        Counter: m.Counter,
                }
                m.strategy = &amp;count
        }</span> else<span class="cov8" title="1"> {
                gauge := gaugeRepo{
                        Gauge: m.Gauge,
                }
                m.strategy = &amp;gauge
        }</span>
}

func (m *LocalStorage) Update(ctx context.Context, metricType string, metricName string, metricValue any) error <span class="cov8" title="1">{
        m.setMetricAlgo(metricType)

        m.rm.Lock()
        defer m.rm.Unlock()

        err := m.strategy.Update(metricType, metricName, metricValue)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error while updating metric", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *LocalStorage) Get(ctx context.Context, metricType string, metricName string) (models.Metrics, error) <span class="cov8" title="1">{
        m.setMetricAlgo(metricType)

        m.rm.RLock()
        defer m.rm.RUnlock()

        metric, err := m.strategy.Get(metricType, metricName)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error while getting metric", zap.Error(err))
                return models.Metrics{}, err
        }</span>
        <span class="cov8" title="1">return metric, nil</span>
}

func (m *LocalStorage) GetAll(ctx context.Context) (map[string]any, error) <span class="cov8" title="1">{
        m.rm.Lock()
        defer m.rm.Unlock()

        res := processmap.ConvertToSingleMap(m.Gauge, m.Counter)

        return res, nil
}</span>

// LoadMetricsFromFile loads metrics from the stated file.
func (m *LocalStorage) LoadMetricsFromFile(fname string) error <span class="cov8" title="1">{
        data, err := os.ReadFile(fname)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">var metricSlice []models.Metrics
        if err := json.Unmarshal(data, &amp;metricSlice); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">m.rm.Lock()
        defer m.rm.Unlock()

        for _, v := range metricSlice </span><span class="cov8" title="1">{
                if v.MType == "gauge" </span><span class="cov8" title="1">{
                        m.Gauge[v.ID] = *v.Value
                }</span> else<span class="cov8" title="1"> if v.MType == "counter" </span><span class="cov8" title="1">{
                        m.Counter[v.ID] = *v.Delta
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *LocalStorage) Ping(ctx context.Context) error <span class="cov8" title="1">{
        if m.Gauge == nil </span><span class="cov8" title="1">{
                logger.Log.Info("gauge local storage not initialized")
                return errors.New("gauge local storage not initialized")
        }</span>

        <span class="cov8" title="1">if m.Counter == nil </span><span class="cov0" title="0">{
                logger.Log.Info("counter local storage not initialized")
                return errors.New("counter local storage not initialized")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SaveAllMetricsToFile periodically saves metrics from local storage to provided file.
func (m *LocalStorage) SaveAllMetricsToFile(FlagStoreInterval int, FlagStorePath string, fname string) error <span class="cov8" title="1">{
        //pauseDuration := time.Duration(FlagStoreInterval) * time.Second
        for </span><span class="cov8" title="1">{
                //time.Sleep(pauseDuration)
                metrics, _ := m.GetAll(context.Background())
                slice := []models.Metrics{}

                for key, v := range metrics </span><span class="cov8" title="1">{
                        var metric models.Metrics
                        if val, ok := v.(float64); ok </span><span class="cov8" title="1">{
                                metric.ID = key
                                metric.Value = &amp;val
                                metric.MType = config.GaugeType
                                slice = append(slice, metric)
                                continue</span>
                        }
                        <span class="cov8" title="1">if val, ok := v.(int64); ok </span><span class="cov8" title="1">{
                                metric.ID = key
                                metric.Delta = &amp;val
                                metric.MType = config.CountType
                                slice = append(slice, metric)
                        }</span>
                }

                <span class="cov8" title="1">data, err := json.MarshalIndent(slice, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("marshalling error", zap.Error(err))
                        return err
                }</span>

                <span class="cov8" title="1">err = os.WriteFile(fname, data, 0606)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error saving metrics to the file", zap.Error(err))
                        return err
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package local

import (
        "sync"

        "github.com/igortoigildin/go-metrics-altering/internal/models"
)

type MetricAlgo interface {
        Update(metricType string, metricName string, metricValue any) error
        Get(metricType string, metricName string) (models.Metrics, error)
}

type counterRepo struct {
        Counter map[string]int64
        rm      sync.Mutex
}

func (c *counterRepo) Update(metricType string, metricName string, metricValue any) error <span class="cov8" title="1">{
        if c.Counter == nil </span><span class="cov0" title="0">{
                c.Counter = make(map[string]int64)
        }</span>
        <span class="cov8" title="1">v, _ := metricValue.(int64)
        c.rm.Lock()
        c.Counter[metricName] += v
        c.rm.Unlock()

        //logger.Log.Info("metric updated successfully", zap.Int64("counter", v))

        return nil</span>
}

func (c *counterRepo) Get(metricType string, metricName string) (models.Metrics, error) <span class="cov8" title="1">{
        var metric models.Metrics

        c.rm.Lock()
        d := c.Counter[metricName]
        c.rm.Unlock()
        metric.Delta = &amp;d
        metric.MType = metricType

        return metric, nil
}</span>

type gaugeRepo struct {
        Gauge map[string]float64
        rm    sync.Mutex
}

func (g *gaugeRepo) Update(metricType string, metricName string, metricValue any) error <span class="cov8" title="1">{
        if g.Gauge == nil </span><span class="cov0" title="0">{
                g.Gauge = make(map[string]float64)
        }</span>
        <span class="cov8" title="1">v, _ := metricValue.(float64)
        g.rm.Lock()
        g.Gauge[metricName] = v
        g.rm.Unlock()

        //logger.Log.Info("metric updated successfully", zap.Float64("gauge", v))

        return nil</span>
}

func (g *gaugeRepo) Get(metricType string, metricName string) (models.Metrics, error) <span class="cov8" title="1">{
        var metric models.Metrics

        g.rm.Lock()
        v := g.Gauge[metricName]
        metric.Value = &amp;v
        g.rm.Unlock()
        metric.MType = metricType

        return metric, nil
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package psql

import (
        "context"
        "database/sql"

        _ "github.com/golang-migrate/migrate/v4/source/file"
        config "github.com/igortoigildin/go-metrics-altering/config/server"
        "github.com/igortoigildin/go-metrics-altering/internal/models"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
        migrate "github.com/igortoigildin/go-metrics-altering/pkg/migrations"
        _ "github.com/lib/pq"

        "go.uber.org/zap"
)

const (
        GaugeType = "gauge"
        CountType = "counter"
        PollCount = "PollCount"
)

type PGStorage struct {
        conn     *sql.DB
        strategy Strategy
}

func New(cfg *config.ConfigServer) (*PGStorage, error) <span class="cov0" title="0">{
        db, err := sql.Open("pgx", cfg.FlagDBDSN)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := migrate.New("migrations", db); err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal("could not migrate db: %s", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return &amp;PGStorage{
                conn: db,
        }, nil</span>
}

func (pg *PGStorage) SetStrategy(metricType string) error <span class="cov8" title="1">{
        if metricType == config.CountType </span><span class="cov8" title="1">{
                count := Count{
                        conn: pg.conn,
                }
                pg.strategy = &amp;count
                return nil
        }</span>

        <span class="cov8" title="1">gauge := Gauge{
                conn: pg.conn,
        }
        pg.strategy = &amp;gauge
        return nil</span>
}

func (pg *PGStorage) Ping(ctx context.Context) error <span class="cov0" title="0">{
        err := pg.conn.PingContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("connection to the database not alive", zap.Error(err))
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (pg *PGStorage) Update(ctx context.Context, metricType string, metricName string, metricValue any) error <span class="cov0" title="0">{
        pg.SetStrategy(metricType)
        return pg.strategy.Update(ctx, metricType, metricName, metricValue)
}</span>

func (pg *PGStorage) Get(ctx context.Context, metricType string, metricName string) (models.Metrics, error) <span class="cov0" title="0">{
        pg.SetStrategy(metricType)
        return pg.strategy.Get(ctx, metricType, metricName)
}</span>

func (pg *PGStorage) GetAll(ctx context.Context) (map[string]any, error) <span class="cov8" title="1">{
        metrics := make(map[string]any, 33)
        rows, err := pg.conn.QueryContext(ctx, `SELECT name, value FROM gauges WHERE type = ?`, GaugeType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        for rows.Next() </span><span class="cov8" title="1">{
                var name string
                var value any
                err = rows.Scan(&amp;name, &amp;value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">metrics[name] = value</span>
        }
        <span class="cov8" title="1">err = rows.Err()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">rows, err = pg.conn.QueryContext(ctx, `SELECT name, value FROM counters WHERE type = ?`, CountType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        for rows.Next() </span><span class="cov8" title="1">{
                var name string
                var value any
                err = rows.Scan(&amp;name, &amp;value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">metrics[name] = value</span>
        }
        <span class="cov8" title="1">err = rows.Err()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return metrics, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package psql

import (
        "context"
        "database/sql"
        "errors"

        "github.com/igortoigildin/go-metrics-altering/internal/models"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
        "go.uber.org/zap"
)

type Strategy interface {
        Update(ctx context.Context, metricType string, metricName string, metricValue any) error
        Get(ctx context.Context, metricType string, metricName string) (models.Metrics, error)
}

type Count struct {
        conn *sql.DB
}

func (c *Count) Update(ctx context.Context, metricType string, metricName string, metricValue any) error <span class="cov0" title="0">{
        _, err := c.conn.ExecContext(ctx, `INSERT INTO counters(name, type, value) VALUES($1, $2, $3) ON CONFLICT (name) DO UPDATE SET value = counters.value + $3`, metricName, metricType, metricValue)
        return err
}</span>

func (c *Count) Get(ctx context.Context, metricType string, metricName string) (models.Metrics, error) <span class="cov8" title="1">{
        var metric models.Metrics
        err := c.conn.QueryRowContext(ctx, "SELECT name, type, value FROM counters WHERE name = ?", metricName).Scan(
                &amp;metric.ID, &amp;metric.MType, &amp;metric.Delta)
        switch </span>{
        case errors.Is(err, sql.ErrNoRows):<span class="cov8" title="1">
                return metric, err</span>
        case err != nil:<span class="cov0" title="0">
                logger.Log.Info("error while obtaining metrics", zap.Error(err))
                return metric, err</span>
        }
        <span class="cov0" title="0">return metric, nil</span>
}

type Gauge struct {
        conn *sql.DB
}

func (g *Gauge) Update(ctx context.Context, metricType string, metricName string, metricValue any) error <span class="cov0" title="0">{
        _, err := g.conn.ExecContext(ctx, "INSERT INTO gauges(name, type, value) VALUES($1, $2, $3)"+
                "ON CONFLICT (name) DO UPDATE SET value = $3", metricName, metricType, metricValue)
        return err
}</span>

func (g *Gauge) Get(ctx context.Context, metricType string, metricName string) (models.Metrics, error) <span class="cov8" title="1">{
        var metric models.Metrics
        err := g.conn.QueryRowContext(ctx, "SELECT name, type, value FROM gauges WHERE name = $1", metricName).Scan(
                &amp;metric.ID, &amp;metric.MType, &amp;metric.Value)
        switch </span>{
        case errors.Is(err, sql.ErrNoRows):<span class="cov8" title="1">
                logger.Log.Info("no rows selected", zap.Error(err))
                return metric, err</span>
        case err != nil:<span class="cov0" title="0">
                return metric, err</span>
        }
        <span class="cov0" title="0">return metric, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package crypt

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
)

func Decrypt(privateKeyPEM []byte, input []byte) ([]byte, error) <span class="cov8" title="1">{

        privateKeyBlock, _ := pem.Decode(privateKeyPEM)
        privateKey, err := x509.ParsePKCS1PrivateKey(privateKeyBlock.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">res, err := rsa.DecryptPKCS1v15(rand.Reader, privateKey, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return res, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package crypt

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
)

func Encrypt(publicKeyPEM []byte, msg []byte) ([]byte, error) <span class="cov8" title="1">{
        publicKeyBlock, _ := pem.Decode(publicKeyPEM)
        publicKey, err := x509.ParsePKIXPublicKey(publicKeyBlock.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ciphertext, err := rsa.EncryptPKCS1v15(rand.Reader, publicKey.(*rsa.PublicKey), msg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return ciphertext, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package crypt

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "io/fs"
        "os"

        config "github.com/igortoigildin/go-metrics-altering/config/server"
)

const (
        publicKey  = "public.pem"
        privateKey = "private.pem"
        keysDir    = "keys"
)

func InitRSAKeys(cfg *config.ConfigServer) error <span class="cov8" title="1">{
        privateKeyPEM, publicKeyPEM, err := GenerateRSAKeys(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = os.MkdirAll("keys", 0777)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = saveKey("/"+privateKey, privateKeyPEM, 0777)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = saveKey("/"+publicKey, publicKeyPEM, 0777)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// InitRSAKeys generates and saves private and public rsa keys.
func GenerateRSAKeys(cfg *config.ConfigServer) ([]byte, []byte, error) <span class="cov8" title="1">{
        privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">publicKey := &amp;privateKey.PublicKey

        privateKeyBytes := x509.MarshalPKCS1PrivateKey(privateKey)

        privateKeyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: privateKeyBytes,
        })

        publicKeyBytes, err := x509.MarshalPKIXPublicKey(publicKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">publicKeyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "RSA PUBLIC KEY",
                Bytes: publicKeyBytes,
        })

        return privateKeyPEM, publicKeyPEM, nil</span>
}

func saveKey(name string, data []byte, perm fs.FileMode) error <span class="cov8" title="1">{
        err := os.WriteFile(keysDir+name, data, perm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package httpserver

import (
        "time"
)

// Option -.
type Option func(*Server)

// Port -.
func Address(address string) (Option, error) <span class="cov8" title="1">{
        return func(s *Server) </span><span class="cov0" title="0">{
                s.server.Addr = address
        }</span>, nil
}

// ReadTimeout -.
func ReadTimeout(timeout time.Duration) (Option, error) <span class="cov8" title="1">{
        return func(s *Server) </span><span class="cov0" title="0">{
                s.server.ReadTimeout = timeout
        }</span>, nil
}

// WriteTimeout -.
func WriteTimeout(timeout time.Duration) (Option, error) <span class="cov8" title="1">{
        return func(s *Server) </span><span class="cov0" title="0">{
                s.server.WriteTimeout = timeout
        }</span>, nil
}

// ShutdownTimeout -.
func ShutdownTimeout(timeout time.Duration) (Option, error) <span class="cov8" title="1">{
        return func(s *Server) </span><span class="cov0" title="0">{
                s.ShutdownTimeout = timeout
        }</span>, nil
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package httpserver

import (
        "context"
        "net/http"
        "time"
)

const (
        _defaultReadTimeout     = 5 * time.Second
        _defaultWriteTimeout    = 5 * time.Second
        _defaultAddr            = ":80"
        _defaultShutdownTimeout = 3 * time.Second
)

// Server -.
type Server struct {
        server          *http.Server
        notify          chan error
        ShutdownTimeout time.Duration
}

// New -.
func New(handler http.Handler, opts ...Option) *Server <span class="cov8" title="1">{
        httpServer := &amp;http.Server{
                Handler:      handler,
                ReadTimeout:  _defaultReadTimeout,
                WriteTimeout: _defaultWriteTimeout,
                Addr:         _defaultAddr,
        }

        s := &amp;Server{
                server:          httpServer,
                notify:          make(chan error, 1),
                ShutdownTimeout: _defaultShutdownTimeout,
        }

        // Custom options
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(s)
        }</span>

        <span class="cov8" title="1">s.start()

        return s</span>
}

func (s *Server) start() <span class="cov8" title="1">{
        go func() </span><span class="cov8" title="1">{
                s.notify &lt;- s.server.ListenAndServe()
                close(s.notify)
        }</span>()
}

// Notify -.
func (s *Server) Notify() &lt;-chan error <span class="cov0" title="0">{
        return s.notify
}</span>

// GracefulShutdown -.
func (s *Server) GracefulShutdown() error <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), s.ShutdownTimeout)
        defer cancel()

        return s.server.Shutdown(ctx)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package logging

import (
        "context"
        "errors"

        "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// This code is simple enough to be copied and not imported.
func InterceptorLogger(l *zap.Logger) logging.Logger <span class="cov8" title="1">{
        return logging.LoggerFunc(func(ctx context.Context, lvl logging.Level, msg string, fields ...any) </span><span class="cov0" title="0">{
                f, _ := prepareFields(fields...)
                logger := l.WithOptions(zap.AddCallerSkip(1)).With(f...)
                checkLevel(logger, lvl, msg)
        }</span>)
}

func checkLevel(logger *zap.Logger, lvl logging.Level, msg string) error <span class="cov8" title="1">{
        switch lvl </span>{
        case logging.LevelDebug:<span class="cov8" title="1">
                logger.Debug(msg)</span>
        case logging.LevelInfo:<span class="cov8" title="1">
                logger.Info(msg)</span>
        case logging.LevelWarn:<span class="cov8" title="1">
                logger.Warn(msg)</span>
        case logging.LevelError:<span class="cov8" title="1">
                logger.Error(msg)</span>
        default:<span class="cov8" title="1">
                return errors.New("unknown level")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func prepareFields(fields ...any) ([]zapcore.Field, error) <span class="cov8" title="1">{
        f := make([]zap.Field, 0, len(fields)/2)

        for i := 0; i &lt; len(fields); i += 2 </span><span class="cov8" title="1">{
                key := fields[i]
                value := fields[i+1]

                switch v := value.(type) </span>{
                case string:<span class="cov8" title="1">
                        f = append(f, zap.String(key.(string), v))</span>
                case int:<span class="cov8" title="1">
                        f = append(f, zap.Int(key.(string), v))</span>
                case bool:<span class="cov8" title="1">
                        f = append(f, zap.Bool(key.(string), v))</span>
                default:<span class="cov0" title="0">
                        f = append(f, zap.Any(key.(string), v))</span>
                }
        }
        <span class="cov8" title="1">return f, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package logger

import "go.uber.org/zap"

var Log *zap.Logger = zap.NewNop()

func Initialize(level string) error <span class="cov8" title="1">{
        lvl, err := zap.ParseAtomicLevel(level)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">cfg := zap.NewProductionConfig()
        cfg.Level = lvl
        zl, err := cfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">Log = zl
        return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package auth provides middleware for basic authorization.
package auth

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "net"
        "net/http"

        config "github.com/igortoigildin/go-metrics-altering/config/server"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
)

// Auth middleware checks whether IP request is in trusted subnet.
func Auth(next http.HandlerFunc, cfg *config.ConfigServer) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if cfg.FlagTrustedSubnet != "" </span><span class="cov0" title="0">{
                        ipStr := r.Header.Get("X-Real-IP")

                        // check whether X-Real-IP is the correct IP-address
                        ip := net.ParseIP(ipStr)
                        if ip == nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusBadRequest)
                                return
                        }</span>

                        <span class="cov0" title="0">isTrusted, err := isIPInTrustedSubnet(ipStr, cfg.FlagTrustedSubnet)
                        if err != nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov0" title="0">if !isTrusted </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusForbidden)
                                return
                        }</span>
                }
                <span class="cov0" title="0">next(w, r)</span>
        })
}

func isIPInTrustedSubnet(ipStr string, trustedSubnet string) (bool, error) <span class="cov8" title="1">{
        ip := net.ParseIP(ipStr)
        if ip == nil </span><span class="cov8" title="1">{
                logger.Log.Error("invalid IP address")
                return false, fmt.Errorf("invalid IP address: %s", ipStr)
        }</span>

        // converting trusted subnet to net.IPNet
        <span class="cov8" title="1">_, trustedNet, err := net.ParseCIDR(trustedSubnet)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid trusted subnet: %s", trustedSubnet)
        }</span>

        // chesk whether ip is in trusted subnet
        <span class="cov8" title="1">return trustedNet.Contains(ip), nil</span>
}

// ValidMAC reports whether messageMAC is a valid HMAC tag for message.
func ValidMAC(message, messageMAC, key []byte) (bool, error) <span class="cov8" title="1">{
        mac := hmac.New(sha256.New, key)
        mac.Write([]byte(message))
        expectedMAC := hex.EncodeToString(mac.Sum(nil))
        return hmac.Equal(messageMAC, []byte(expectedMAC)), nil
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package compress provides middleware for request compression.
package compress

import (
        "compress/gzip"
        "io"
        "net/http"
        "strings"
)

type compressWriter struct {
        w  http.ResponseWriter
        zw *gzip.Writer
}

func newCompressWriter(w http.ResponseWriter) *compressWriter <span class="cov8" title="1">{
        return &amp;compressWriter{
                w:  w,
                zw: gzip.NewWriter(w),
        }
}</span>

func (c *compressWriter) Header() http.Header <span class="cov8" title="1">{
        return c.w.Header()
}</span>

func (c *compressWriter) Write(p []byte) (int, error) <span class="cov8" title="1">{
        return c.zw.Write(p)
}</span>

func (c *compressWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        if statusCode &lt; 300 </span><span class="cov0" title="0">{
                c.w.Header().Set("Content-Encoding", "gzip")
        }</span>
        <span class="cov0" title="0">c.w.WriteHeader(statusCode)</span>
}

func (c *compressWriter) Close() error <span class="cov8" title="1">{
        return c.zw.Close()
}</span>

type compressReader struct {
        r  io.ReadCloser
        zr *gzip.Reader
}

func newCompressReader(r io.ReadCloser) (*compressReader, error) <span class="cov8" title="1">{
        zr, err := gzip.NewReader(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;compressReader{
                r:  r,
                zr: zr,
        }, nil</span>
}

func (c compressReader) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        return c.zr.Read(p)
}</span>

func (c *compressReader) Close() error <span class="cov8" title="1">{
        if err := c.r.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return c.zr.Close()</span>
}

func GzipMiddleware(h http.HandlerFunc) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ow := w
                acceptEncoding := r.Header.Get("Accept-Encoding")
                supportsGzip := strings.Contains(acceptEncoding, "gzip")
                if supportsGzip </span><span class="cov8" title="1">{
                        cw := newCompressWriter(w)
                        ow = cw
                        defer cw.Close()
                }</span>
                <span class="cov8" title="1">contentEncoding := r.Header.Get("Content-Encoding")
                sendsGzip := strings.Contains(contentEncoding, "gzip")
                if sendsGzip </span><span class="cov8" title="1">{
                        cr, err := newCompressReader(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov8" title="1">r.Body = cr
                        defer cr.Close()</span>
                }
                <span class="cov8" title="1">h.ServeHTTP(ow, r)</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package logging provides middleware for logging http requests and responses.

package logging

import (
        "net/http"
        "time"

        "github.com/igortoigildin/go-metrics-altering/pkg/logger"

        "go.uber.org/zap"
)

type (
        // info struct in regards to reply
        responseData struct {
                status int
                size   int
        }
        loggingResponseWriter struct {
                http.ResponseWriter
                responseData *responseData
        }
)

func (r *loggingResponseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        size, err := r.ResponseWriter.Write(b)
        r.responseData.size += size
        return size, err
}</span>

func (r *loggingResponseWriter) WriteHeader(statusCode int) <span class="cov8" title="1">{
        r.ResponseWriter.WriteHeader(statusCode)
        r.responseData.status = statusCode
}</span>

// WithLogging adds code to regester info regarding request and returns new http.Handler
func WithLogging(h http.Handler) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                start := time.Now()
                responseData := &amp;responseData{
                        status: 0,
                        size:   0,
                }
                lw := loggingResponseWriter{
                        ResponseWriter: w, //using original http.ResponseWriter
                        responseData:   responseData,
                }
                h.ServeHTTP(&amp;lw, r) //using updated http.ResponseWriter
                duration := time.Since(start)
                logger.Log.Info("got incoming HTTP request",
                        zap.String("uri", r.RequestURI),
                        zap.String("method", r.Method),
                        zap.Int("status", responseData.status),
                        zap.String("duration", duration.String()),
                        zap.Int("size", responseData.size),
                )
        }</span>)
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package timeout provides middleware for adding context with timeout to  http request.
package timeout

import (
        "context"
        "net/http"
        "time"

        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
)

func Timeout(timeout time.Duration, next http.HandlerFunc) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(r.Context(), timeout)
                defer cancel()

                r = r.WithContext(ctx)

                processDone := make(chan bool)
                go func() </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        processDone &lt;- true
                }</span>()

                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Log.Info("HTTP Request timed out")
                        w.WriteHeader(http.StatusRequestTimeout)
                        w.Write([]byte("timed out"))</span>
                case &lt;-processDone:<span class="cov0" title="0"></span>
                }
        })
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package processjson provides helpful functions for reading and writing JSON requests.
package processjson

import (
        "encoding/json"
        "net/http"
)

type ErrorResponse struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}

func ReadJSON(r *http.Request, dst any) error <span class="cov8" title="1">{
        err := json.NewDecoder(r.Body).Decode(&amp;dst)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func WriteJSON(rw http.ResponseWriter, status int, data any, headers http.Header) error <span class="cov8" title="1">{
        js, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">js = append(js, '\n')
        for key, value := range headers </span><span class="cov0" title="0">{
                rw.Header()[key] = value
        }</span>

        <span class="cov8" title="1">rw.Header().Set("Content-Type", "application/json")
        rw.WriteHeader(status)
        rw.Write(js)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package processmap provides helpful function for combination of two maps.
package processmap

func ConvertToSingleMap(a map[string]float64, b map[string]int64) map[string]interface{} <span class="cov8" title="1">{
        c := make(map[string]interface{}, 33)
        for i, v := range a </span><span class="cov8" title="1">{
                c[i] = v
        }</span>
        <span class="cov8" title="1">for j, l := range b </span><span class="cov8" title="1">{
                c[j] = l
        }</span>
        <span class="cov8" title="1">return c</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
