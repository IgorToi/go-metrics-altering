
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agent: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/igortoigildin/go-metrics-altering/cmd/agent/agent.go (0.0%)</option>
				
				<option value="file1">github.com/igortoigildin/go-metrics-altering/cmd/server/main.go (0.0%)</option>
				
				<option value="file2">github.com/igortoigildin/go-metrics-altering/cmd/staticlint/checker/checker.go (62.5%)</option>
				
				<option value="file3">github.com/igortoigildin/go-metrics-altering/cmd/staticlint/main.go (0.0%)</option>
				
				<option value="file4">github.com/igortoigildin/go-metrics-altering/config/agent/config.go (88.9%)</option>
				
				<option value="file5">github.com/igortoigildin/go-metrics-altering/config/server/config.go (83.9%)</option>
				
				<option value="file6">github.com/igortoigildin/go-metrics-altering/internal/agent/agent.go (0.0%)</option>
				
				<option value="file7">github.com/igortoigildin/go-metrics-altering/internal/agent/app/app.go (10.9%)</option>
				
				<option value="file8">github.com/igortoigildin/go-metrics-altering/internal/agent/memory/memory.go (94.7%)</option>
				
				<option value="file9">github.com/igortoigildin/go-metrics-altering/internal/agent/sendJSONMetric.go (71.0%)</option>
				
				<option value="file10">github.com/igortoigildin/go-metrics-altering/internal/agent/sendURLMetric.go (72.3%)</option>
				
				<option value="file11">github.com/igortoigildin/go-metrics-altering/internal/models/models.go (100.0%)</option>
				
				<option value="file12">github.com/igortoigildin/go-metrics-altering/internal/server/api/handlers.go (88.6%)</option>
				
				<option value="file13">github.com/igortoigildin/go-metrics-altering/internal/server/api/mocks/Storage.go (74.0%)</option>
				
				<option value="file14">github.com/igortoigildin/go-metrics-altering/internal/server/api/router.go (100.0%)</option>
				
				<option value="file15">github.com/igortoigildin/go-metrics-altering/internal/server/app/app.go (20.0%)</option>
				
				<option value="file16">github.com/igortoigildin/go-metrics-altering/internal/storage/inmemory/local.go (83.1%)</option>
				
				<option value="file17">github.com/igortoigildin/go-metrics-altering/internal/storage/inmemory/setMetricAlgo.go (92.9%)</option>
				
				<option value="file18">github.com/igortoigildin/go-metrics-altering/internal/storage/postgres/postgres.go (47.0%)</option>
				
				<option value="file19">github.com/igortoigildin/go-metrics-altering/internal/storage/postgres/strategy.go (50.0%)</option>
				
				<option value="file20">github.com/igortoigildin/go-metrics-altering/internal/storage/storage.go (54.5%)</option>
				
				<option value="file21">github.com/igortoigildin/go-metrics-altering/pkg/crypt/decrypt.go (75.0%)</option>
				
				<option value="file22">github.com/igortoigildin/go-metrics-altering/pkg/crypt/encrypt.go (75.0%)</option>
				
				<option value="file23">github.com/igortoigildin/go-metrics-altering/pkg/crypt/savekey.go (75.0%)</option>
				
				<option value="file24">github.com/igortoigildin/go-metrics-altering/pkg/httpServer/options.go (50.0%)</option>
				
				<option value="file25">github.com/igortoigildin/go-metrics-altering/pkg/httpServer/server.go (84.6%)</option>
				
				<option value="file26">github.com/igortoigildin/go-metrics-altering/pkg/logger/logger.go (90.0%)</option>
				
				<option value="file27">github.com/igortoigildin/go-metrics-altering/pkg/middlewares/auth/auth.go (100.0%)</option>
				
				<option value="file28">github.com/igortoigildin/go-metrics-altering/pkg/middlewares/compress/compress.go (78.8%)</option>
				
				<option value="file29">github.com/igortoigildin/go-metrics-altering/pkg/middlewares/logging/logger.go (100.0%)</option>
				
				<option value="file30">github.com/igortoigildin/go-metrics-altering/pkg/middlewares/timeout/timeout.go (8.3%)</option>
				
				<option value="file31">github.com/igortoigildin/go-metrics-altering/pkg/processJSON/processJSON.go (64.7%)</option>
				
				<option value="file32">github.com/igortoigildin/go-metrics-altering/pkg/processMap/processMap.go (100.0%)</option>
				
				<option value="file33">github.com/igortoigildin/go-metrics-altering/templates/fs.go (75.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"

        config "github.com/igortoigildin/go-metrics-altering/config/agent"
        "github.com/igortoigildin/go-metrics-altering/internal/agent/app"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
)

func main() <span class="cov0" title="0">{
        cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("error while logading config", err)
                return
        }</span>
        <span class="cov0" title="0">if err := logger.Initialize(cfg.FlagLogLevel); err != nil </span><span class="cov0" title="0">{
                log.Println("error while initializing logger", err)
                return
        }</span>

        <span class="cov0" title="0">app.Run(cfg)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "log"

        config "github.com/igortoigildin/go-metrics-altering/config/server"
        "github.com/igortoigildin/go-metrics-altering/internal/server/app"
        "go.uber.org/zap"

        "github.com/igortoigildin/go-metrics-altering/pkg/crypt"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
)

func main() <span class="cov0" title="0">{
        cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("error while logading config", err)
                return
        }</span>

        <span class="cov0" title="0">if err = logger.Initialize(cfg.FlagLogLevel); err != nil </span><span class="cov0" title="0">{
                log.Println("error while initializing logger", err)
                return
        }</span>

        <span class="cov0" title="0">err = crypt.InitRSAKeys(cfg)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error while generating rsa keys", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">app.Run(cfg)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package exitcheck defines an Analyzer that reports os.Exit function usage.
package exitcheck

import (
        "go/ast"

        "golang.org/x/tools/go/analysis"
)

// ExitCheckAnalyzer describes exitcheck analyzer and its options.
var ExitCheckAnalyzer = &amp;analysis.Analyzer{
        Name: "exitcheck",
        Doc:  "checker helps determine if os.exit exists",
        Run:  Run,
}

// Run applies the analyzer to a package.
// It returns an error if the analyzer failed.
func Run(pass *analysis.Pass) (interface{}, error) <span class="cov8" title="1">{
        for _, file := range pass.Files </span><span class="cov8" title="1">{
                ast.Inspect(file, func(node ast.Node) bool </span><span class="cov8" title="1">{
                        if x, ok := node.(*ast.CallExpr); ok </span><span class="cov0" title="0">{
                                if s, ok := x.Fun.(*ast.SelectorExpr); ok </span><span class="cov0" title="0">{
                                        if s.Sel.Name == "Exit" </span><span class="cov0" title="0">{
                                                pass.Reportf(s.Pos(), "using os.Exit is prohibbited")
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">return true</span>
                })
        }
        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "encoding/json"
        "log"
        "os"
        "path/filepath"

        exitcheck "github.com/igortoigildin/go-metrics-altering/cmd/staticlint/checker"
        "github.com/kisielk/errcheck/errcheck"
        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/multichecker"
        "golang.org/x/tools/go/analysis/passes/nilness"
        "golang.org/x/tools/go/analysis/passes/printf"
        "golang.org/x/tools/go/analysis/passes/shadow"
        "golang.org/x/tools/go/analysis/passes/structtag"
        "honnef.co/go/tools/staticcheck"
        "honnef.co/go/tools/unused"
)

// Config — config file name.
const Config = `config.json`

// ConfigData defines struct with config file.
type ConfigData struct {
        Staticcheck []string
}

func main() <span class="cov0" title="0">{
        appfile, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">data, err := os.ReadFile(filepath.Join(filepath.Dir(appfile), Config))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // cfg - JSON file with statickcheck id of checks needed for multichecker.
        <span class="cov0" title="0">var cfg ConfigData
        if err = json.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // mychecks collects all analyzers inclueded in multichecker.
        <span class="cov0" title="0">mychecks := []*analysis.Analyzer{
                exitcheck.ExitCheckAnalyzer,
                printf.Analyzer,
                shadow.Analyzer,
                structtag.Analyzer,
                nilness.Analyzer,
                errcheck.Analyzer,
                unused.Analyzer.Analyzer,
        }
        checks := make(map[string]bool)
        for _, v := range cfg.Staticcheck </span><span class="cov0" title="0">{
                checks[v] = true
        }</span>
        // Add analyzers which stated in config fail.
        <span class="cov0" title="0">for _, v := range staticcheck.Analyzers </span><span class="cov0" title="0">{
                if checks[v.Analyzer.Name] </span><span class="cov0" title="0">{
                        mychecks = append(mychecks, v.Analyzer)
                }</span>
        }

        // Muiltichecker examines Go source code and reports suspicious constructs,
        // such as Printf calls whose arguments do not align with the format
        // string. It uses heuristics that do not guarantee all reports are
        // genuine problems, but it can find errors not caught by the compilers.
        //
        // Multichecker registers the following analyzers:
        // exitcheck        reports os.Exit function usage
        // printf                 checks consistency of Printf format strings and arguments
        // shadow                checks for shadowed variables
        // structtag         checks struct field tags are well formed
        // errcheck                checks unchecked errors in Go code
        // unused                finds unused code
        // nilness                inspects the control-flow graph of an SSA function and reports
        // errors such as nil pointer dereferences and degenerate nil pointer comparisons
        //
        // By default all analyzers are run.
        // To select specific analyzers, use the -NAME flag for each one,
        // or -NAME=false to run all analyzers not explicitly disabled.
        //
        // For basic usage, just give the package path of interest as the first argument:
        //
        // multichecker cmd/testdata
        //
        // To check all packages beneath the current directory:
        // multichecker ./...
        <span class="cov0" title="0">multichecker.Main(
                mychecks...,
        )</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "encoding/json"
        "flag"
        "log"
        "os"
        "strconv"
        "time"
)

const (
        PollInterval   = 2
        GaugeType      = "gauge"
        CountType      = "counter"
        PollCount      = "PollCount"
        StatusOK       = 200
        ProtocolScheme = "http://"
        cfgName        = "config/agent/configAgent.json"
)

const defaultAgentConfig = `{
    "address": "localhost:8080", 
    "report_interval": 1, 
    "poll_interval": 1, 
    "crypto_key": "/path/to/key.pem"
}`

type ConfigAgent struct {
        FlagRunAddr        string        `json:"address"`
        FlagReportInterval int           `json:"report_interval"`
        FlagPollInterval   int           `json:"poll_interval"`
        FlagLogLevel       string        `json:"log_level"`
        FlagHashKey        string        `json:"hash_key"`
        FlagRateLimit      int           `json:"rate_limit"`
        PauseDuration      time.Duration // Time - agent will wait to send metrics again
        URL                string
        FlagCryptoKey      string `json:"crypto_key"`
        FlagConfigName     string `json:"config_name"`
        FlagRSAEncryption  bool
}

func LoadConfig() (*ConfigAgent, error) <span class="cov8" title="1">{
        cfg := new(ConfigAgent)

        if err := os.WriteFile(cfgName, []byte(defaultAgentConfig), 0666); err != nil </span><span class="cov8" title="1">{
                log.Println(err)
        }</span>

        <span class="cov8" title="1">configFile, err := os.Open(cfgName)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("error while opening config.json", err)
        }</span>
        <span class="cov8" title="1">defer configFile.Close()

        err = json.NewDecoder(configFile).Decode(&amp;cfg)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("error while decoding data from config.json", err)
        }</span>

        // var err error
        <span class="cov8" title="1">flag.StringVar(&amp;cfg.FlagRunAddr, "a", "localhost:8080", "address and port to run server")
        flag.StringVar(&amp;cfg.FlagLogLevel, "u", "info", "log level")
        flag.IntVar(&amp;cfg.FlagReportInterval, "r", 10, "frequency of metrics being sent")
        flag.IntVar(&amp;cfg.FlagPollInterval, "p", 0, "frequency of metrics being received from the runtime package")
        flag.IntVar(&amp;cfg.FlagRateLimit, "l", 3, "rate limit")
        flag.StringVar(&amp;cfg.FlagHashKey, "k", "", "hash key")
        flag.StringVar(&amp;cfg.FlagCryptoKey, "crypto-key", "keys/public.pem", "path to public key")
        flag.StringVar(&amp;cfg.FlagConfigName, "c", "configAgent.json", "name of the config with json data")
        flag.BoolVar(&amp;cfg.FlagRSAEncryption, "rsa-bool", true, "whether communication should be encrypted using rsa keys")
        flag.Parse()

        if envRunAddr := os.Getenv("ADDRESS"); envRunAddr != "" </span><span class="cov8" title="1">{
                cfg.FlagRunAddr = envRunAddr
        }</span>

        <span class="cov8" title="1">if envCofigName := os.Getenv("CONFIG"); envCofigName != "" </span><span class="cov0" title="0">{
                cfg.FlagConfigName = envCofigName
        }</span>

        <span class="cov8" title="1">if envRateLimit := os.Getenv("RATE_LIMIT"); envRateLimit != "" </span><span class="cov8" title="1">{
                cfg.FlagRateLimit, err = strconv.Atoi(envRateLimit)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal("error while parsing rate limit", err)
                }</span>
        }

        <span class="cov8" title="1">if envRSAKey := os.Getenv("CRYPTO_KEY"); envRSAKey != "" </span><span class="cov0" title="0">{
                cfg.FlagHashKey = envRSAKey
        }</span>

        <span class="cov8" title="1">if envHashValue := os.Getenv("KEY"); envHashValue != "" </span><span class="cov8" title="1">{
                cfg.FlagHashKey = envHashValue
        }</span>

        <span class="cov8" title="1">if envRoportInterval := os.Getenv("REPORT_INTERVAL"); envRoportInterval != "" </span><span class="cov8" title="1">{
                cfg.FlagReportInterval, err = strconv.Atoi(envRoportInterval)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal("error while parsing report interval", err)
                }</span>
        }

        <span class="cov8" title="1">if envPollInterval := os.Getenv("POLL_INTERVAL"); envPollInterval != "" </span><span class="cov8" title="1">{
                cfg.FlagPollInterval, err = strconv.Atoi(envPollInterval)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal("error while parsing poll interval", err)
                }</span>
        }

        <span class="cov8" title="1">if envLogLevel := os.Getenv("LOG_LEVEL"); envLogLevel != "" </span><span class="cov8" title="1">{
                cfg.FlagLogLevel = envLogLevel
        }</span>

        <span class="cov8" title="1">cfg.PauseDuration = time.Duration(cfg.FlagReportInterval) * time.Second
        cfg.URL = ProtocolScheme + cfg.FlagRunAddr
        return cfg, err</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "encoding/json"
        "errors"
        "flag"
        "html/template"
        "log"
        "os"
        "strconv"
        "time"
)

const (
        GaugeType = "gauge"
        CountType = "counter"
        PollCount = "PollCount"
        timeout   = 10
        cfgName   = "config/server/configServer.json"
)

const defaultSrvConfig = `{
    "address": "localhost:8080",
    "restore": true,
    "store_interval": 1,
    "store_file": "/path/to/file.db", 
    "database_dsn": "",
    "crypto_key": "/path/to/key.pem"
}`

var errCfgVarEmpty = errors.New("configs variable not set")

type ConfigServer struct {
        FlagRunAddr       string `json:"address"`
        Template          *template.Template
        FlagLogLevel      string `json:"log_level"`
        FlagStoreInterval int    `json:"store_interval"`
        FlagStorePath     string `json:"store_file"`
        FlagRestore       bool   `json:"restore"`
        FlagDBDSN         string `json:"database_dsn"`
        FlagHashKey       string `json:"hash_key"`
        ContextTimout     time.Duration
        FlagCryptoKey     string `json:"crypto_key"`
        FlagConfigName    string `json:"config_name"`
        FlagRSAEncryption bool
}

func LoadConfig() (*ConfigServer, error) <span class="cov8" title="1">{
        // ps := fmt.Sprintf("host=%s user=%s password=%s dbname=%s sslmode=disable",`localhost`, `postgres`, `XXXXX`, `metrics`)
        cfg := new(ConfigServer)

        if err := os.WriteFile(cfgName, []byte(defaultSrvConfig), 0777); err != nil </span><span class="cov8" title="1">{
                log.Println(err)
        }</span>

        <span class="cov8" title="1">configFile, err := os.Open(cfgName)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("error while opening config.json", err)
        }</span>
        <span class="cov8" title="1">defer configFile.Close()

        err = json.NewDecoder(configFile).Decode(&amp;cfg)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("error while decoding data from config.json", err)
        }</span>

        <span class="cov8" title="1">flag.StringVar(&amp;cfg.FlagRunAddr, "a", ":8080", "address and port to run server")
        flag.StringVar(&amp;cfg.FlagLogLevel, "l", "info", "log level")
        flag.IntVar(&amp;cfg.FlagStoreInterval, "i", 1, "metrics backup interval")
        flag.StringVar(&amp;cfg.FlagStorePath, "f", "/tmp/metrics-db.json", "metrics backup storage path")
        flag.BoolVar(&amp;cfg.FlagRestore, "r", false, "true if load from backup is needed")
        flag.StringVar(&amp;cfg.FlagDBDSN, "d", "", "string with DB DSN")
        flag.StringVar(&amp;cfg.FlagHashKey, "k", "", "hash key")
        flag.StringVar(&amp;cfg.FlagCryptoKey, "crypto-key", "keys", "path to private key")
        flag.StringVar(&amp;cfg.FlagConfigName, "c", "configServer.json", "name of the config with json data")
        flag.BoolVar(&amp;cfg.FlagRSAEncryption, "rsa-bool", false, "whether communication should be encrypted using rsa keys")
        flag.Parse()

        if envRunAddr := os.Getenv("ADDRESS"); envRunAddr != "" </span><span class="cov8" title="1">{
                cfg.FlagRunAddr = envRunAddr
        }</span>

        <span class="cov8" title="1">if envRSAKey := os.Getenv("CRYPTO_KEY"); envRSAKey != "" </span><span class="cov0" title="0">{
                cfg.FlagHashKey = envRSAKey
        }</span>

        <span class="cov8" title="1">if envCofigName := os.Getenv("CONFIG"); envCofigName != "" </span><span class="cov0" title="0">{
                cfg.FlagConfigName = envCofigName
        }</span>

        <span class="cov8" title="1">if envLogLevel := os.Getenv("LOG_LEVEL"); envLogLevel != "" </span><span class="cov8" title="1">{
                cfg.FlagLogLevel = envLogLevel
        }</span>

        <span class="cov8" title="1">if envHashKey := os.Getenv("KEY"); envHashKey != "" </span><span class="cov8" title="1">{
                cfg.FlagHashKey = envHashKey
        }</span>

        <span class="cov8" title="1">if envStorageInterval := os.Getenv("STORE_INTERVAL"); envStorageInterval != "" </span><span class="cov8" title="1">{
                // parse string env variable
                v, err := strconv.Atoi(envStorageInterval)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">cfg.FlagStoreInterval = v</span>
        }

        <span class="cov8" title="1">if envStorePath := os.Getenv("FILE_STORAGE_PATH"); envStorePath != "" </span><span class="cov0" title="0">{
                cfg.FlagStorePath = envStorePath
        }</span>

        <span class="cov8" title="1">if envDBDSN := os.Getenv("DATABASE_DSN"); envDBDSN != "" </span><span class="cov8" title="1">{
                cfg.FlagDBDSN = envDBDSN
        }</span>

        <span class="cov8" title="1">if envFlagRestore := os.Getenv("RESTORE"); envFlagRestore != "" </span><span class="cov8" title="1">{
                // parse bool env variable
                v, err := strconv.ParseBool(envFlagRestore)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">cfg.FlagRestore = v</span>
        }

        // check if any config variables is empty
        <span class="cov8" title="1">if !cfg.validate() </span><span class="cov0" title="0">{
                return nil, errCfgVarEmpty
        }</span>

        <span class="cov8" title="1">cfg.ContextTimout = timeout * time.Second
        return cfg, err</span>
}

func (cfg *ConfigServer) validate() bool <span class="cov8" title="1">{
        if cfg.FlagRunAddr == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if cfg.FlagLogLevel == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if cfg.FlagStorePath == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package agent accumulates, runtime metrics
// and sends it to predefined server every poll interval.

package agent

import (
        config "github.com/igortoigildin/go-metrics-altering/config/agent"
        "github.com/igortoigildin/go-metrics-altering/internal/models"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
        "go.uber.org/zap"
)

// SendMetrics reads metrics from metricsChan and sends it server address as defined by agent config.
func SendMetrics(metricsChan &lt;-chan models.Metrics, cfg *config.ConfigAgent) <span class="cov0" title="0">{
        for metric := range metricsChan </span><span class="cov0" title="0">{

                switch metric.MType </span>{
                case config.CountType:<span class="cov0" title="0">
                        err := sendURLCounter(cfg, int(*metric.Delta))
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Error("unexpected sending url counter metric error:", zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">err = SendJSONCounter(int(*metric.Delta), cfg)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Error("unexpected sending json counter metric error:", zap.Error(err))
                        }</span>
                case config.GaugeType:<span class="cov0" title="0">
                        err := SendURLGauge(cfg, *metric.Value, metric.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Error("unexpected sending url gauge metric error:", zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">err = SendJSONGauge(metric.ID, cfg, *metric.Value)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Error("unexpected sending json gauge metric error:", zap.Error(err))
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package app

import (
        "context"
        "fmt"
        "os/signal"
        "sync"
        "syscall"
        "time"

        config "github.com/igortoigildin/go-metrics-altering/config/agent"
        "github.com/igortoigildin/go-metrics-altering/internal/agent"
        "github.com/igortoigildin/go-metrics-altering/internal/agent/memory"
        "github.com/igortoigildin/go-metrics-altering/internal/models"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
)

var buildVersion string = "N/A"
var buildDate string = "N/A"
var buildCommit string = "N/A"

func Run(cfg *config.ConfigAgent) <span class="cov0" title="0">{
        printInfo()

        memoryStats := memory.New()
        var wg sync.WaitGroup
        metricsChan := make(chan models.Metrics, 33)

        ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGTERM, syscall.SIGINT, syscall.SIGQUIT)
        defer stop()

        wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        time.Sleep(cfg.PauseDuration)
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                logger.Log.Info("Stop updating inmemory runtime metrics")
                                wg.Done()
                                return</span>
                        default:<span class="cov0" title="0">
                                memoryStats.UpdateRunTimeStat(cfg)</span>
                        }
                }
        }()

        <span class="cov0" title="0">wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        time.Sleep(cfg.PauseDuration)
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                logger.Log.Info("Stop updating inmemory CPU RAM metrics")
                                wg.Done()
                                return</span>
                        default:<span class="cov0" title="0">
                                memoryStats.UpdateCPURAMStat(cfg)</span>
                        }
                }
        }()

        <span class="cov0" title="0">for w := 1; w &lt;= cfg.FlagRateLimit; w++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        agent.SendMetrics(metricsChan, cfg)
                }</span>()
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        time.Sleep(cfg.PauseDuration)
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                logger.Log.Info("Stop filling metrics chan with new metrics")
                                close(metricsChan)
                                return</span>
                        default:<span class="cov0" title="0">
                                wg.Add(1)
                                memoryStats.ReadMetrics(cfg, metricsChan)
                                wg.Done()</span>
                        }
                }
        }()

        <span class="cov0" title="0">wg.Wait()

        logger.Log.Info("Graceful agent shutdown complete...")</span>
}

func printInfo() error <span class="cov8" title="1">{
        fmt.Printf("Build version: %s\n", buildVersion)
        fmt.Printf("Build date: %s\n", buildDate)
        fmt.Printf("Build commit: %s\n", buildCommit)

        logger.Log.Info("loading metrics...")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package memory accumulates updated metrics,
// which is being used and consumed by agent.

package memory

import (
        "errors"
        "math/rand/v2"
        "runtime"
        "sync"

        config "github.com/igortoigildin/go-metrics-altering/config/agent"
        "github.com/igortoigildin/go-metrics-altering/internal/models"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
        "github.com/shirou/gopsutil/cpu"
        "github.com/shirou/gopsutil/mem"
        "go.uber.org/zap"
)

var (
        ErrConnectionFailed = errors.New("connection failed")
)

// MemoryStats provides temporary storage for collected metrics.
type MemoryStats struct {
        GaugeMetrics  map[string]float64
        CounterMetric int
        RunTimeMem    *runtime.MemStats
        rwm           sync.RWMutex
}

// NewMemoryStats is constructor for MemoryStats.
func New() *MemoryStats <span class="cov8" title="1">{
        return &amp;MemoryStats{
                GaugeMetrics: make(map[string]float64),
                RunTimeMem:   &amp;runtime.MemStats{},
        }
}</span>

// ReadMetrics collects runtime metrics from memory and sends it to agent via metricsChan.
func (m *MemoryStats) ReadMetrics(cfg *config.ConfigAgent, metricsChan chan models.Metrics) <span class="cov8" title="1">{
        m.rwm.Lock()
        for name, value := range m.GaugeMetrics </span><span class="cov8" title="1">{
                metric := models.GaugeConstructor(value, name)
                metricsChan &lt;- metric
        }</span>
        <span class="cov8" title="1">m.rwm.Unlock()
        metric := models.CounterConstructor(int64(m.CounterMetric))
        metricsChan &lt;- metric</span>
}

// UpdateCPURAMStat collects and updates in MemoryStats CPU metrics.
func (m *MemoryStats) UpdateCPURAMStat(cfg *config.ConfigAgent) <span class="cov8" title="1">{
        if m.GaugeMetrics == nil </span><span class="cov0" title="0">{
                m.GaugeMetrics = make(map[string]float64, 3)
        }</span>

        <span class="cov8" title="1">cpuNumber, err := cpu.Counts(true)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error while loading cpu Counts:", zap.Error(err))
        }</span>
        <span class="cov8" title="1">v, err := mem.VirtualMemory()
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error while loading virtualmemoryStat:", zap.Error(err))
        }</span>
        <span class="cov8" title="1">m.rwm.Lock()
        m.GaugeMetrics["TotalMemory"] = float64(v.Total)
        m.GaugeMetrics["FreeMemory"] = float64(v.Free)
        m.GaugeMetrics["CPUutilization1"] = float64(cpuNumber)
        m.rwm.Unlock()</span>
}

// UpdateRunTimeStat collects and updates in MemoryStats runtime metrics.
func (m *MemoryStats) UpdateRunTimeStat(cfg *config.ConfigAgent) <span class="cov8" title="1">{
        runtime.ReadMemStats(m.RunTimeMem)
        m.rwm.Lock()
        m.GaugeMetrics["Alloc"] = float64(m.RunTimeMem.Alloc)
        m.GaugeMetrics["BuckHashSys"] = float64(m.RunTimeMem.BuckHashSys)
        m.GaugeMetrics["Frees"] = float64(m.RunTimeMem.Frees)
        m.GaugeMetrics["GCCPUFraction"] = float64(m.RunTimeMem.GCCPUFraction)
        m.GaugeMetrics["GCSys"] = float64(m.RunTimeMem.GCSys)
        m.GaugeMetrics["HeapAlloc"] = float64(m.RunTimeMem.HeapAlloc)
        m.GaugeMetrics["HeapIdle"] = float64(m.RunTimeMem.HeapIdle)
        m.GaugeMetrics["HeapInuse"] = float64(m.RunTimeMem.HeapInuse)
        m.GaugeMetrics["HeapObjects"] = float64(m.RunTimeMem.HeapObjects)
        m.GaugeMetrics["HeapReleased"] = float64(m.RunTimeMem.HeapReleased)
        m.GaugeMetrics["HeapSys"] = float64(m.RunTimeMem.HeapSys)
        m.GaugeMetrics["LastGC"] = float64(m.RunTimeMem.LastGC)
        m.GaugeMetrics["Lookups"] = float64(m.RunTimeMem.Lookups)
        m.GaugeMetrics["MCacheInuse"] = float64(m.RunTimeMem.MCacheInuse)
        m.GaugeMetrics["MCacheSys"] = float64(m.RunTimeMem.MCacheSys)
        m.GaugeMetrics["MSpanInuse"] = float64(m.RunTimeMem.MSpanInuse)
        m.GaugeMetrics["MSpanSys"] = float64(m.RunTimeMem.MSpanSys)
        m.GaugeMetrics["Mallocs"] = float64(m.RunTimeMem.Mallocs)
        m.GaugeMetrics["NextGC"] = float64(m.RunTimeMem.NextGC)
        m.GaugeMetrics["NumForcedGC"] = float64(m.RunTimeMem.NumForcedGC)
        m.GaugeMetrics["NumGC"] = float64(m.RunTimeMem.NumGC)
        m.GaugeMetrics["OtherSys"] = float64(m.RunTimeMem.OtherSys)
        m.GaugeMetrics["NextGC"] = float64(m.RunTimeMem.NextGC)
        m.GaugeMetrics["NumForcedGC"] = float64(m.RunTimeMem.NumForcedGC)
        m.GaugeMetrics["NumGC"] = float64(m.RunTimeMem.NumGC)
        m.GaugeMetrics["OtherSys"] = float64(m.RunTimeMem.OtherSys)
        m.GaugeMetrics["PauseTotalNs"] = float64(m.RunTimeMem.PauseTotalNs)
        m.GaugeMetrics["StackInuse"] = float64(m.RunTimeMem.StackInuse)
        m.GaugeMetrics["StackSys"] = float64(m.RunTimeMem.StackSys)
        m.GaugeMetrics["Sys"] = float64(m.RunTimeMem.StackSys)
        m.GaugeMetrics["TotalAlloc"] = float64(m.RunTimeMem.TotalAlloc)
        m.GaugeMetrics["RandomValue"] = rand.Float64()
        m.CounterMetric++
        m.rwm.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package agent

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "time"

        "github.com/go-resty/resty/v2"
        config "github.com/igortoigildin/go-metrics-altering/config/agent"
        "github.com/igortoigildin/go-metrics-altering/internal/models"
        "github.com/igortoigildin/go-metrics-altering/pkg/crypt"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
        "go.uber.org/zap"
)

const updEndpoint = "/update/"

var (
        ErrConnectionFailed = errors.New("connection failed")
)

// SendJSONGauge accepts and sends gauge metrics in JSON format to predefined by config server address.
func SendJSONGauge(metricName string, cfg *config.ConfigAgent, value float64) error <span class="cov8" title="1">{
        agent := resty.New()

        if metricName == "" </span><span class="cov8" title="1">{
                logger.Log.Info("metric data not complete")
                return errors.New("metric data not complete")
        }</span>

        <span class="cov8" title="1">metric := models.GaugeConstructor(value, metricName)
        req := agent.R().SetHeader("Content-Type", "application/json")

        metricsJSON, err := json.Marshal(metric)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("marshalling json error:", zap.Error(err))
                return err
        }</span>

        // signing metric value with sha256 and setting header accordingly
        <span class="cov8" title="1">if cfg.FlagHashKey != "" </span><span class="cov8" title="1">{
                key := []byte(cfg.FlagHashKey)
                h := hmac.New(sha256.New, key)
                h.Write(metricsJSON)
                dst := h.Sum(nil)
                req.SetHeader("HashSHA256", fmt.Sprintf("%x", dst))
        }</span>

        <span class="cov8" title="1">if cfg.FlagRSAEncryption </span><span class="cov8" title="1">{
                publicKeyPEM, err := os.ReadFile(cfg.FlagCryptoKey)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error while reading rsa public key:", zap.Error(err))
                }</span>

                // encrypting using public key
                <span class="cov8" title="1">metricsJSON, err = crypt.Encrypt(publicKeyPEM, metricsJSON)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error while encrypting data")
                }</span>
        }

        <span class="cov8" title="1">_, err = req.SetBody(metricsJSON).Post(cfg.URL + updEndpoint)
        if err != nil </span><span class="cov8" title="1">{
                // send again n times if timeout error
                switch </span>{
                case os.IsTimeout(err):<span class="cov0" title="0">
                        for _, delay := range []time.Duration{time.Second, 2 * time.Second, 3 * time.Second} </span><span class="cov0" title="0">{
                                time.Sleep(delay)
                                if _, err = req.Post(req.URL); err == nil </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">return ErrConnectionFailed</span>
                default:<span class="cov8" title="1">
                        logger.Log.Info("unexpected sending metric error:", zap.Error(err))
                        return err</span>
                }
        }

        <span class="cov8" title="1">logger.Log.Info("sent JSON gauge metric:", zap.Float64(metricName, value))
        return nil</span>
}

// SendJSONCounter accepts and sends gauge metrics in JSON format to predefined by config server address.
func SendJSONCounter(counter int, cfg *config.ConfigAgent) error <span class="cov8" title="1">{
        agent := resty.New()

        metric := models.CounterConstructor(int64(counter))
        req := agent.R().SetHeader("Content-Type", "application/json")

        metricJSON, err := json.Marshal(metric)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("marshalling json error:", zap.Error(err))
                return err
        }</span>
        // signing metric value with sha256 and setting header accordingly
        <span class="cov8" title="1">if cfg.FlagHashKey != "" </span><span class="cov8" title="1">{
                key := []byte(cfg.FlagHashKey)
                h := hmac.New(sha256.New, key)
                h.Write(metricJSON)
                dst := h.Sum(nil)
                req.SetHeader("HashSHA256", fmt.Sprintf("%x", dst))
        }</span>

        <span class="cov8" title="1">if cfg.FlagRSAEncryption </span><span class="cov8" title="1">{
                publicKeyPEM, err := os.ReadFile(cfg.FlagCryptoKey)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error while reading rsa public key:", zap.Error(err))
                        return err
                }</span>
                // encrypting using public key
                <span class="cov8" title="1">metricJSON, err = crypt.Encrypt(publicKeyPEM, metricJSON)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error while encrypting data")
                        return err
                }</span>
        }

        <span class="cov8" title="1">_, err = req.SetBody(metricJSON).Post(cfg.URL + updEndpoint)
        if err != nil </span><span class="cov8" title="1">{
                // send again n times if timeout error
                switch </span>{
                case os.IsTimeout(err):<span class="cov0" title="0">
                        for _, delay := range []time.Duration{time.Second, 2 * time.Second, 3 * time.Second} </span><span class="cov0" title="0">{
                                time.Sleep(delay)
                                if _, err = req.Post(req.URL); err == nil </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">return ErrConnectionFailed</span>
                default:<span class="cov8" title="1">
                        logger.Log.Info("unexpected sending metric error:", zap.Error(err))
                        return err</span>
                }
        }

        <span class="cov8" title="1">logger.Log.Info("sent JSON counter metric:", zap.Int("conuter", counter))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package agent

import (
        "crypto/hmac"
        "crypto/sha256"
        "fmt"
        "net/http"
        "os"
        "strconv"
        "time"

        config "github.com/igortoigildin/go-metrics-altering/config/agent"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
        "go.uber.org/zap"
)

// SendJSONCounter accepts and sends counter metrics in URL format to predefined by config server address.
func sendURLCounter(cfg *config.ConfigAgent, counter int) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/update/%s/%s/%s", config.GaugeType, config.PollCount, strconv.Itoa(counter))
        r, err := http.NewRequest("POST", cfg.URL+path, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error while preparing http request", zap.Error(err))
        }</span>

        // signing metric value with sha256 and setting header accordingly
        <span class="cov8" title="1">if cfg.FlagHashKey != "" </span><span class="cov8" title="1">{
                key := []byte(cfg.FlagHashKey)
                h := hmac.New(sha256.New, key)
                h.Write(nil)
                dst := h.Sum(nil)
                r.Header = http.Header{
                        "HashSHA256": {fmt.Sprintf("%x", dst)},
                }
        }</span>

        <span class="cov8" title="1">client := http.Client{}
        _, err = client.Do(r)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case os.IsTimeout(err):<span class="cov0" title="0">
                        for _, delay := range []time.Duration{time.Second, 2 * time.Second, 3 * time.Second} </span><span class="cov0" title="0">{
                                time.Sleep(delay)
                                if _, err = client.Do(r); err == nil </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">return ErrConnectionFailed</span>
                default:<span class="cov8" title="1">
                        return err</span>
                }
        }

        <span class="cov8" title="1">logger.Log.Info("sent url counter metric:", zap.Int("conuter", counter))
        return nil</span>
}

// SendURLGauge accepts and sends gauge metrics in URL format to predefined by config server address.
func SendURLGauge(cfg *config.ConfigAgent, value float64, metricName string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/update/%s/%s/%s", config.GaugeType, metricName, strconv.FormatFloat(value, 'f', 6, 64))
        r, err := http.NewRequest("POST", cfg.URL+path, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error while preparing http request", zap.Error(err))
        }</span>

        // signing metric value with sha256 and setting header accordingly
        <span class="cov8" title="1">if cfg.FlagHashKey != "" </span><span class="cov8" title="1">{
                key := []byte(cfg.FlagHashKey)
                h := hmac.New(sha256.New, key)
                h.Write(nil)
                dst := h.Sum(nil)
                r.Header = http.Header{
                        "HashSHA256": {fmt.Sprintf("%x", dst)},
                }
        }</span>

        <span class="cov8" title="1">client := http.Client{}

        _, err = client.Do(r)

        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case os.IsTimeout(err):<span class="cov0" title="0">
                        err := retryURL(client, r)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                default:<span class="cov0" title="0">
                        return err</span>
                }
        }

        <span class="cov8" title="1">logger.Log.Info("sent url gauge metric:", zap.Float64(metricName, value))
        return nil</span>
}

func retryURL(client http.Client, r *http.Request) error <span class="cov8" title="1">{
        for _, delay := range []time.Duration{time.Second, 2 * time.Second, 3 * time.Second} </span><span class="cov8" title="1">{
                time.Sleep(delay)
                if _, err := client.Do(r); err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return ErrConnectionFailed</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package models provides entity of metric.

package models

import config "github.com/igortoigildin/go-metrics-altering/config/agent"

type Metrics struct {
        ID    string   `json:"id"`              // имя метрики
        MType string   `json:"type"`            // параметр, принимающий значение gauge или counter
        Delta *int64   `json:"delta,omitempty"` // значение метрики в случае передачи counter
        Value *float64 `json:"value,omitempty"` // значение метрики в случае передачи gauge
}

// CounterConstructor constructor for counter metric model.
func CounterConstructor(delta int64) Metrics <span class="cov8" title="1">{
        return Metrics{
                ID:    config.PollCount,
                MType: config.CountType,
                Delta: &amp;delta,
        }
}</span>

// GaugeConstructor constructor for gauge metric model.
func GaugeConstructor(value float64, name string) Metrics <span class="cov8" title="1">{
        return Metrics{
                ID:    name,
                MType: config.GaugeType,
                Value: &amp;value,
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package api

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "io"
        "net/http"
        "os"
        "strconv"

        _ "net/http/pprof" // подключаем пакет pprof

        config "github.com/igortoigildin/go-metrics-altering/config/server"
        "github.com/igortoigildin/go-metrics-altering/internal/models"
        "github.com/igortoigildin/go-metrics-altering/pkg/crypt"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
        processjson "github.com/igortoigildin/go-metrics-altering/pkg/processJSON"
        "go.uber.org/zap"
)

const (
        path = "keys/private.pem"
)

//go:generate go run github.com/vektra/mockery/v2@v2.45.0 --name=Storage
type Storage interface {
        Update(ctx context.Context, metricType string, metricName string, metricValue any) error
        Get(ctx context.Context, metricType string, metricName string) (models.Metrics, error)
        GetAll(ctx context.Context) (map[string]any, error)
        Ping(ctx context.Context) error
}

func ping(Storage Storage) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ctx := r.Context()
                if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                        logger.Log.Info("got request with bad method", zap.String("method", r.Method))
                        w.WriteHeader(http.StatusMethodNotAllowed)
                        return
                }</span>
                <span class="cov8" title="1">err := Storage.Ping(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
        })
}

func updates(Storage Storage) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ctx := r.Context()

                if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                        logger.Log.Info("got request with bad method", zap.String("method", r.Method))
                        w.WriteHeader(http.StatusMethodNotAllowed)
                        return
                }</span>

                <span class="cov8" title="1">metrics := make([]models.Metrics, 0)
                err := processjson.ReadJSON(r, &amp;metrics)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("cannot decode request JSON body", zap.Error(err))
                        w.WriteHeader(http.StatusBadRequest)
                        return
                }</span>

                // iterating through []Metrics and adding it to db one by one
                <span class="cov8" title="1">for _, metric := range metrics </span><span class="cov8" title="1">{
                        if metric.MType != config.GaugeType &amp;&amp; metric.MType != config.CountType </span><span class="cov8" title="1">{
                                logger.Log.Info("usupported request type", zap.String("type", metric.MType))
                                w.WriteHeader(http.StatusUnprocessableEntity)
                                return
                        }</span>
                        <span class="cov8" title="1">switch metric.MType </span>{
                        case config.GaugeType:<span class="cov8" title="1">
                                err := Storage.Update(ctx, metric.MType, metric.ID, metric.Value)
                                if err != nil </span><span class="cov8" title="1">{
                                        logger.Log.Info("error while updating value", zap.Error(err))
                                        w.WriteHeader(http.StatusInternalServerError)
                                        return
                                }</span>
                        case config.CountType:<span class="cov8" title="1">
                                err := Storage.Update(ctx, metric.MType, metric.ID, metric.Delta)
                                if err != nil </span><span class="cov8" title="1">{
                                        logger.Log.Info("error while updating value", zap.Error(err))
                                        w.WriteHeader(http.StatusInternalServerError)
                                        return
                                }</span>
                        }
                }
                <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")</span>
        })
}

func updateMetric(Storage Storage) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{

                ctx := r.Context()

                if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                        logger.Log.Info("got request with bad method", zap.String("method", r.Method))
                        w.WriteHeader(http.StatusMethodNotAllowed)
                        return
                }</span>

                //obtaining private key from file
                <span class="cov8" title="1">privateKeyPEM, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error while reading key", zap.Error(err))
                        return
                }</span>

                <span class="cov8" title="1">body, err := io.ReadAll(r.Body)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Error reading request body", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">defer r.Body.Close()

                // decrypting request body using private key
                plaintext, err := crypt.Decrypt(privateKeyPEM, body)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error while decryping data")
                        return
                }</span>

                <span class="cov8" title="1">var req models.Metrics

                err = json.Unmarshal(plaintext, &amp;req)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error: ", zap.Error(err))
                }</span>

                <span class="cov8" title="1">switch req.MType </span>{
                case config.GaugeType:<span class="cov8" title="1">
                        err := Storage.Update(ctx, req.MType, req.ID, req.Value)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Log.Info("error while updating value", zap.Error(err))
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                case config.CountType:<span class="cov8" title="1">
                        err := Storage.Update(ctx, req.MType, req.ID, req.Delta)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Log.Info("error while updating value", zap.Error(err))
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                default:<span class="cov8" title="1">
                        logger.Log.Info("usupported request type", zap.String("type", req.MType))
                        w.WriteHeader(http.StatusUnprocessableEntity)
                        return</span>
                }

                <span class="cov8" title="1">resp := models.Metrics{
                        ID:    req.ID,
                        MType: req.MType,
                        Value: req.Value,
                        Delta: req.Delta,
                }
                err = processjson.WriteJSON(w, http.StatusOK, resp, nil)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error encoding response", zap.Error(err))
                        return
                }</span>
        })
}

func getAllmetrics(Storage Storage) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Content-Type", "text/html; charset=utf-8")
                w.Header().Add("Content-Encoding", "gzip")
                metrics, err := Storage.GetAll(r.Context())
                if err != nil </span><span class="cov8" title="1">{
                        logger.Log.Info("error", zap.Error(err))
                        w.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">err = processjson.WriteJSON(w, http.StatusOK, metrics, nil)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error encoding response", zap.Error(err))
                        return
                }</span>
        })
}

func getMetric(Storage Storage) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ctx := r.Context()

                if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                        logger.Log.Info("got request with bad method", zap.String("method", r.Method))
                        w.WriteHeader(http.StatusMethodNotAllowed)
                        return
                }</span>

                <span class="cov8" title="1">var req models.Metrics
                err := processjson.ReadJSON(r, &amp;req)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("cannot decode request JSON body", zap.Error(err))
                        w.WriteHeader(http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">if req.MType != config.GaugeType &amp;&amp; req.MType != config.CountType </span><span class="cov8" title="1">{
                        logger.Log.Info("usupported request type", zap.String("type", req.MType))
                        w.WriteHeader(http.StatusUnprocessableEntity)
                        return
                }</span>

                <span class="cov8" title="1">resp := models.Metrics{
                        ID:    req.ID,
                        MType: req.MType,
                }

                switch req.MType </span>{
                case config.GaugeType:<span class="cov8" title="1">
                        res, err := Storage.Get(ctx, req.MType, req.ID)
                        if err != nil </span><span class="cov8" title="1">{
                                switch </span>{
                                case errors.Is(err, sql.ErrNoRows):<span class="cov8" title="1">
                                        logger.Log.Info("error while obtaining metric", zap.Error(err))
                                        w.WriteHeader(http.StatusNotFound)
                                        return</span>
                                default:<span class="cov8" title="1">
                                        logger.Log.Info("error while obtaining metric", zap.Error(err))
                                        w.WriteHeader(http.StatusInternalServerError)
                                        return</span>
                                }
                        }
                        <span class="cov8" title="1">resp.Value = res.Value</span>
                case config.CountType:<span class="cov8" title="1">
                        res, err := Storage.Get(ctx, req.MType, req.ID)
                        if err != nil </span><span class="cov8" title="1">{
                                switch </span>{
                                case errors.Is(err, sql.ErrNoRows):<span class="cov8" title="1">
                                        logger.Log.Info("error while obtaining metric", zap.Error(err))
                                        w.WriteHeader(http.StatusNotFound)
                                        return</span>
                                default:<span class="cov8" title="1">
                                        logger.Log.Info("error while obtaining metric", zap.Error(err))
                                        w.WriteHeader(http.StatusInternalServerError)
                                        return</span>
                                }
                        }
                        <span class="cov8" title="1">resp.Delta = res.Delta</span>
                }

                <span class="cov8" title="1">w.Header().Add("Content-Encoding", "gzip")
                err = processjson.WriteJSON(w, http.StatusOK, resp, nil)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error encoding response", zap.Error(err))
                        return
                }</span>
        })
}

func updatePathHandler(LocalStorage Storage) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                metricType := r.PathValue("metricType")
                metricName := r.PathValue("metricName")
                metricValue := r.PathValue("metricValue")

                switch metricType </span>{
                case config.GaugeType:<span class="cov8" title="1">
                        metricValueConverted, err := strconv.ParseFloat(metricValue, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Log.Error("error parsing metric value to float", zap.Error(err))
                                w.WriteHeader(http.StatusBadRequest)
                                return
                        }</span>

                        <span class="cov8" title="1">err = LocalStorage.Update(context.TODO(), config.GaugeType, metricName, metricValueConverted)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Log.Error("error while updating metric", zap.Error(err))
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>

                case config.CountType:<span class="cov8" title="1">
                        metricValueConverted, err := strconv.ParseInt(metricValue, 10, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Log.Error("error parsing metric value to int", zap.Error(err))
                                w.WriteHeader(http.StatusBadRequest)
                                return
                        }</span>

                        <span class="cov8" title="1">err = LocalStorage.Update(context.TODO(), config.CountType, metricName, metricValueConverted)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Log.Error("error while updating metric", zap.Error(err))
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                default:<span class="cov8" title="1">
                        w.WriteHeader(http.StatusBadRequest)
                        return</span>
                }
                <span class="cov8" title="1">w.Header().Set("Content-Type", "text/plain; charset=utf-8")</span>
        })
}

func valuePathHandler(LocalStorage Storage) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{

                metricType := r.PathValue("metricType")
                metricName := r.PathValue("metricName")

                switch metricType </span>{
                case config.GaugeType:<span class="cov8" title="1">
                        metric, err := LocalStorage.Get(context.TODO(), config.GaugeType, metricName)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Log.Error("error while loading metric", zap.Error(err))
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov8" title="1">w.Write([]byte(strconv.FormatFloat(*metric.Value, 'f', -1, 64)))</span>
                case config.CountType:<span class="cov8" title="1">
                        metric, err := LocalStorage.Get(context.TODO(), config.CountType, config.PollCount)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Log.Error("error while loading metric", zap.Error(err))
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov8" title="1">w.Write([]byte(strconv.FormatInt(*metric.Delta, 10)))</span>
                default:<span class="cov8" title="1">
                        logger.Log.Info("usupported request type", zap.String("type", metricType))
                        w.WriteHeader(http.StatusUnprocessableEntity)
                        return</span>
                }
        })
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by mockery v2.45.0. DO NOT EDIT.

package mocks

import (
        context "context"

        models "github.com/igortoigildin/go-metrics-altering/internal/models"
        mock "github.com/stretchr/testify/mock"
)

// Storage is an autogenerated mock type for the Storage type
type Storage struct {
        mock.Mock
}

// Get provides a mock function with given fields: ctx, metricType, metricName
func (_m *Storage) Get(ctx context.Context, metricType string, metricName string) (models.Metrics, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, metricType, metricName)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Get")</span>
        }

        <span class="cov8" title="1">var r0 models.Metrics
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (models.Metrics, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, metricType, metricName)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string, string) models.Metrics); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, metricType, metricName)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(models.Metrics)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, metricType, metricName)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetAll provides a mock function with given fields: ctx
func (_m *Storage) GetAll(ctx context.Context) (map[string]interface{}, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAll")</span>
        }

        <span class="cov8" title="1">var r0 map[string]interface{}
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context) (map[string]interface{}, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context) map[string]interface{}); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(map[string]interface{})
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// Ping provides a mock function with given fields: ctx
func (_m *Storage) Ping(ctx context.Context) error <span class="cov8" title="1">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Ping")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// Update provides a mock function with given fields: ctx, metricType, metricName, metricValue
func (_m *Storage) Update(ctx context.Context, metricType string, metricName string, metricValue interface{}) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, metricType, metricName, metricValue)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Update")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, metricType, metricName, metricValue)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// NewStorage creates a new instance of Storage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewStorage(t interface {
        mock.TestingT
        Cleanup(func())
}) *Storage <span class="cov8" title="1">{
        mock := &amp;Storage{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package api

import (
        "context"
        "net/http"
        "text/template"

        config "github.com/igortoigildin/go-metrics-altering/config/server"
        "github.com/igortoigildin/go-metrics-altering/pkg/middlewares/compress"
        "github.com/igortoigildin/go-metrics-altering/pkg/middlewares/logging"
        "github.com/igortoigildin/go-metrics-altering/pkg/middlewares/timeout"
        "github.com/igortoigildin/go-metrics-altering/templates"
)

var t *template.Template

func Router(ctx context.Context, cfg *config.ConfigServer, storage Storage) *http.ServeMux <span class="cov8" title="1">{
        t = templates.ParseTemplate()

        mux := http.NewServeMux()
        mux.HandleFunc("GET /value/{metricType}/{metricName}", logging.WithLogging(compress.GzipMiddleware((http.HandlerFunc(valuePathHandler(storage))))))
        mux.HandleFunc("POST /update/{metricType}/{metricName}/{metricValue}", logging.WithLogging(compress.GzipMiddleware((http.HandlerFunc(updatePathHandler(storage))))))
        mux.HandleFunc("GET /ping", timeout.Timeout(cfg.ContextTimout, logging.WithLogging(compress.GzipMiddleware(http.HandlerFunc(ping(storage))))))
        mux.HandleFunc("GET /", timeout.Timeout(cfg.ContextTimout, logging.WithLogging(compress.GzipMiddleware((http.HandlerFunc(getAllmetrics(storage)))))))
        mux.HandleFunc("POST /updates/", timeout.Timeout(cfg.ContextTimout, logging.WithLogging(compress.GzipMiddleware((http.HandlerFunc(updates(storage)))))))
        mux.HandleFunc("POST /value/", timeout.Timeout(cfg.ContextTimout, logging.WithLogging(compress.GzipMiddleware((http.HandlerFunc(getMetric(storage)))))))
        mux.HandleFunc("POST /update/", timeout.Timeout(cfg.ContextTimout, logging.WithLogging(compress.GzipMiddleware((http.HandlerFunc(updateMetric(storage)))))))

        return mux
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package app

import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "syscall"

        config "github.com/igortoigildin/go-metrics-altering/config/server"
        server "github.com/igortoigildin/go-metrics-altering/internal/server/api"
        storage "github.com/igortoigildin/go-metrics-altering/internal/storage"
        httpServer "github.com/igortoigildin/go-metrics-altering/pkg/httpServer"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
        _ "github.com/jackc/pgx/v5/stdlib"
        "go.uber.org/zap"
)

var buildVersion string = "N/A"
var buildDate string = "N/A"
var buildCommit string = "N/A"

func Run(cfg *config.ConfigServer) <span class="cov0" title="0">{
        printInfo()

        ctx := context.Background()

        // Storage
        storage := storage.New(cfg)

        // Handlers
        r := server.Router(ctx, cfg, storage)

        logger.Log.Info("Starting server on", zap.String("address", cfg.FlagRunAddr))

        // HTTP server
        srv, _ := httpServer.Address(cfg.FlagRunAddr)
        httpSrv := httpServer.New(r, srv)

        // waiting signal
        interrupt := make(chan os.Signal, 1)
        signal.Notify(interrupt, syscall.SIGTERM, syscall.SIGINT, syscall.SIGQUIT)

        select </span>{
        case s := &lt;-interrupt:<span class="cov0" title="0">
                logger.Log.Info("Received: ", zap.String("signal", s.String()))</span>
        case err := &lt;-httpSrv.Notify():<span class="cov0" title="0">
                logger.Log.Error("error:", zap.Error(err))</span>
        }

        // graceful shutdown
        <span class="cov0" title="0">err := httpSrv.GracefulShutdown()
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error:", zap.Error(err))
        }</span>

        <span class="cov0" title="0">logger.Log.Info("Graceful server shutdown complete...")</span>
}

func printInfo() error <span class="cov8" title="1">{
        fmt.Printf("Build version: %s\n", buildVersion)
        fmt.Printf("Build date: %s\n", buildDate)
        fmt.Printf("Build commit: %s\n", buildCommit)

        return nil
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package local storage implementation for inmemory Storage interface.
package local

import (
        "context"
        "encoding/json"
        "errors"
        "os"
        "sync"

        config "github.com/igortoigildin/go-metrics-altering/config/agent"
        "github.com/igortoigildin/go-metrics-altering/internal/models"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
        processmap "github.com/igortoigildin/go-metrics-altering/pkg/processMap"
        "go.uber.org/zap"
)

const pollCount = "PollCount"

type LocalStorage struct {
        rm       sync.RWMutex
        Gauge    map[string]float64
        Counter  map[string]int64
        strategy MetricAlgo
}

func New() *LocalStorage <span class="cov8" title="1">{
        return &amp;LocalStorage{
                Counter: map[string]int64{pollCount: 0},
                Gauge:   map[string]float64{},
        }
}</span>

func (m *LocalStorage) setMetricAlgo(metricType string) <span class="cov8" title="1">{
        if metricType == config.CountType </span><span class="cov8" title="1">{
                count := counterRepo{
                        Counter: m.Counter,
                }
                m.strategy = &amp;count
        }</span> else<span class="cov8" title="1"> {
                gauge := gaugeRepo{
                        Gauge: m.Gauge,
                }
                m.strategy = &amp;gauge
        }</span>
}

func (m *LocalStorage) Update(ctx context.Context, metricType string, metricName string, metricValue any) error <span class="cov8" title="1">{
        m.setMetricAlgo(metricType)

        m.rm.Lock()
        defer m.rm.Unlock()

        err := m.strategy.Update(metricType, metricName, metricValue)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error while updating metric", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *LocalStorage) Get(ctx context.Context, metricType string, metricName string) (models.Metrics, error) <span class="cov8" title="1">{
        m.setMetricAlgo(metricType)

        m.rm.RLock()
        defer m.rm.RUnlock()

        metric, err := m.strategy.Get(metricType, metricName)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error while getting metric", zap.Error(err))
                return models.Metrics{}, err
        }</span>
        <span class="cov8" title="1">return metric, nil</span>
}

func (m *LocalStorage) GetAll(ctx context.Context) (map[string]any, error) <span class="cov8" title="1">{
        m.rm.Lock()
        defer m.rm.Unlock()

        res := processmap.ConvertToSingleMap(m.Gauge, m.Counter)

        return res, nil
}</span>

// LoadMetricsFromFile loads metrics from the stated file.
func (m *LocalStorage) LoadMetricsFromFile(fname string) error <span class="cov8" title="1">{
        data, err := os.ReadFile(fname)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">var metricSlice []models.Metrics
        if err := json.Unmarshal(data, &amp;metricSlice); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">m.rm.Lock()
        defer m.rm.Unlock()

        for _, v := range metricSlice </span><span class="cov8" title="1">{
                if v.MType == "gauge" </span><span class="cov8" title="1">{
                        m.Gauge[v.ID] = *v.Value
                }</span> else<span class="cov8" title="1"> if v.MType == "counter" </span><span class="cov8" title="1">{
                        m.Counter[v.ID] = *v.Delta
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *LocalStorage) Ping(ctx context.Context) error <span class="cov8" title="1">{
        if m.Gauge == nil </span><span class="cov8" title="1">{
                logger.Log.Info("gauge local storage not initialized")
                return errors.New("gauge local storage not initialized")
        }</span>

        <span class="cov8" title="1">if m.Counter == nil </span><span class="cov0" title="0">{
                logger.Log.Info("counter local storage not initialized")
                return errors.New("counter local storage not initialized")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SaveAllMetricsToFile periodically saves metrics from local storage to provided file.
func (m *LocalStorage) SaveAllMetricsToFile(FlagStoreInterval int, FlagStorePath string, fname string) error <span class="cov8" title="1">{
        //pauseDuration := time.Duration(FlagStoreInterval) * time.Second
        for </span><span class="cov8" title="1">{
                //time.Sleep(pauseDuration)
                metrics, _ := m.GetAll(context.Background())
                slice := []models.Metrics{}

                for key, v := range metrics </span><span class="cov8" title="1">{
                        var metric models.Metrics
                        if val, ok := v.(float64); ok </span><span class="cov8" title="1">{
                                metric.ID = key
                                metric.Value = &amp;val
                                metric.MType = config.GaugeType
                                slice = append(slice, metric)
                                continue</span>
                        }
                        <span class="cov8" title="1">if val, ok := v.(int64); ok </span><span class="cov8" title="1">{
                                metric.ID = key
                                metric.Delta = &amp;val
                                metric.MType = config.CountType
                                slice = append(slice, metric)
                        }</span>
                }

                <span class="cov8" title="1">data, err := json.MarshalIndent(slice, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("marshalling error", zap.Error(err))
                        return err
                }</span>

                <span class="cov8" title="1">err = os.WriteFile(fname, data, 0606)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error saving metrics to the file", zap.Error(err))
                        return err
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package local

import (
        "sync"

        "github.com/igortoigildin/go-metrics-altering/internal/models"
)

type MetricAlgo interface {
        Update(metricType string, metricName string, metricValue any) error
        Get(metricType string, metricName string) (models.Metrics, error)
}

type counterRepo struct {
        Counter map[string]int64
        rm      sync.Mutex
}

func (c *counterRepo) Update(metricType string, metricName string, metricValue any) error <span class="cov8" title="1">{
        if c.Counter == nil </span><span class="cov0" title="0">{
                c.Counter = make(map[string]int64)
        }</span>
        <span class="cov8" title="1">v, _ := metricValue.(int64)
        c.rm.Lock()
        c.Counter[metricName] += v
        c.rm.Unlock()
        return nil</span>
}

func (c *counterRepo) Get(metricType string, metricName string) (models.Metrics, error) <span class="cov8" title="1">{
        var metric models.Metrics

        c.rm.Lock()
        d := c.Counter[metricName]
        c.rm.Unlock()
        metric.Delta = &amp;d
        metric.MType = metricType

        return metric, nil
}</span>

type gaugeRepo struct {
        Gauge map[string]float64
        rm    sync.Mutex
}

func (g *gaugeRepo) Update(metricType string, metricName string, metricValue any) error <span class="cov8" title="1">{
        if g.Gauge == nil </span><span class="cov0" title="0">{
                g.Gauge = make(map[string]float64)
        }</span>
        <span class="cov8" title="1">v, _ := metricValue.(float64)
        g.rm.Lock()
        g.Gauge[metricName] = v
        g.rm.Unlock()
        return nil</span>
}
func (g *gaugeRepo) Get(metricType string, metricName string) (models.Metrics, error) <span class="cov8" title="1">{
        var metric models.Metrics

        g.rm.Lock()
        v := g.Gauge[metricName]
        metric.Value = &amp;v
        g.rm.Unlock()
        metric.MType = metricType

        return metric, nil
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package psql

import (
        "context"
        "database/sql"
        "errors"

        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        config "github.com/igortoigildin/go-metrics-altering/config/server"
        "github.com/igortoigildin/go-metrics-altering/internal/models"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
        _ "github.com/lib/pq"

        "go.uber.org/zap"
)

const (
        GaugeType = "gauge"
        CountType = "counter"
        PollCount = "PollCount"
)

type PGStorage struct {
        conn     *sql.DB
        strategy Strategy
}

func New(cfg *config.ConfigServer) *PGStorage <span class="cov0" title="0">{
        dbDSN := cfg.FlagDBDSN

        db, err := sql.Open("pgx", dbDSN)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error while connecting to DB", zap.Error(err))
        }</span>
        <span class="cov0" title="0">logger.Log.Info("database connection pool established")

        // Migrating DB
        if err := runMigrations("migrations", db); err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal("could not migrate db: %s", zap.Error(err))
        }</span>

        <span class="cov0" title="0">logger.Log.Info("database connection established")

        rep := &amp;PGStorage{
                conn: db,
        }

        return rep</span>
}

func runMigrations(migrationsPath string, db *sql.DB) error <span class="cov0" title="0">{
        if migrationsPath == "" </span><span class="cov0" title="0">{
                return errors.New("missing migrations path")
        }</span>
        <span class="cov0" title="0">instance, err := postgres.WithInstance(db, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal("migration error", zap.Error(err))
        }</span>

        <span class="cov0" title="0">migrator, err := migrate.NewWithDatabaseInstance("file://migrations", "postgres", instance)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal("migration error", zap.Error(err))
        }</span>
        <span class="cov0" title="0">if err = migrator.Up(); err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                logger.Log.Fatal("migration error", zap.Error(err))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (pg *PGStorage) SetStrategy(metricType string) error <span class="cov8" title="1">{
        if metricType == config.CountType </span><span class="cov8" title="1">{
                count := Count{
                        conn: pg.conn,
                }
                pg.strategy = &amp;count
                return nil
        }</span>

        <span class="cov8" title="1">gauge := Gauge{
                conn: pg.conn,
        }
        pg.strategy = &amp;gauge
        return nil</span>
}

func (pg *PGStorage) Ping(ctx context.Context) error <span class="cov0" title="0">{
        err := pg.conn.PingContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("connection to the database not alive", zap.Error(err))
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (pg *PGStorage) Update(ctx context.Context, metricType string, metricName string, metricValue any) error <span class="cov0" title="0">{
        pg.SetStrategy(metricType)
        return pg.strategy.Update(ctx, metricType, metricName, metricValue)
}</span>

func (pg *PGStorage) Get(ctx context.Context, metricType string, metricName string) (models.Metrics, error) <span class="cov0" title="0">{
        pg.SetStrategy(metricType)
        return pg.strategy.Get(ctx, metricType, metricName)
}</span>

func (pg *PGStorage) GetAll(ctx context.Context) (map[string]any, error) <span class="cov8" title="1">{
        metrics := make(map[string]any, 33)
        rows, err := pg.conn.QueryContext(ctx, `SELECT name, value FROM gauges WHERE type = ?`, GaugeType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        for rows.Next() </span><span class="cov8" title="1">{
                var name string
                var value any
                err = rows.Scan(&amp;name, &amp;value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">metrics[name] = value</span>
        }
        <span class="cov8" title="1">err = rows.Err()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">rows, err = pg.conn.QueryContext(ctx, `SELECT name, value FROM counters WHERE type = ?`, CountType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()
        for rows.Next() </span><span class="cov8" title="1">{
                var name string
                var value any
                err = rows.Scan(&amp;name, &amp;value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">metrics[name] = value</span>
        }
        <span class="cov8" title="1">err = rows.Err()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return metrics, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package psql

import (
        "context"
        "database/sql"
        "errors"

        "github.com/igortoigildin/go-metrics-altering/internal/models"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
        "go.uber.org/zap"
)

type Strategy interface {
        Update(ctx context.Context, metricType string, metricName string, metricValue any) error
        Get(ctx context.Context, metricType string, metricName string) (models.Metrics, error)
}

type Count struct {
        conn *sql.DB
}

func (c *Count) Update(ctx context.Context, metricType string, metricName string, metricValue any) error <span class="cov0" title="0">{
        _, err := c.conn.ExecContext(ctx, `INSERT INTO counters(name, type, value) VALUES($1, $2, $3) ON CONFLICT (name) DO UPDATE SET value = counters.value + $3`, metricName, metricType, metricValue)
        return err
}</span>

func (c *Count) Get(ctx context.Context, metricType string, metricName string) (models.Metrics, error) <span class="cov8" title="1">{
        var metric models.Metrics
        err := c.conn.QueryRowContext(ctx, "SELECT name, type, value FROM counters WHERE name = ?", metricName).Scan(
                &amp;metric.ID, &amp;metric.MType, &amp;metric.Delta)
        switch </span>{
        case errors.Is(err, sql.ErrNoRows):<span class="cov8" title="1">
                return metric, err</span>
        case err != nil:<span class="cov0" title="0">
                logger.Log.Info("error while obtaining metrics", zap.Error(err))
                return metric, err</span>
        }
        <span class="cov0" title="0">return metric, nil</span>
}

type Gauge struct {
        conn *sql.DB
}

func (g *Gauge) Update(ctx context.Context, metricType string, metricName string, metricValue any) error <span class="cov0" title="0">{
        _, err := g.conn.ExecContext(ctx, "INSERT INTO gauges(name, type, value) VALUES($1, $2, $3)"+
                "ON CONFLICT (name) DO UPDATE SET value = $3", metricName, metricType, metricValue)
        return err
}</span>

func (g *Gauge) Get(ctx context.Context, metricType string, metricName string) (models.Metrics, error) <span class="cov8" title="1">{
        var metric models.Metrics
        err := g.conn.QueryRowContext(ctx, "SELECT name, type, value FROM gauges WHERE name = $1", metricName).Scan(
                &amp;metric.ID, &amp;metric.MType, &amp;metric.Value)
        switch </span>{
        case errors.Is(err, sql.ErrNoRows):<span class="cov8" title="1">
                logger.Log.Info("no rows selected", zap.Error(err))
                return metric, err</span>
        case err != nil:<span class="cov0" title="0">
                return metric, err</span>
        }
        <span class="cov0" title="0">return metric, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package storage

import (
        "context"

        config "github.com/igortoigildin/go-metrics-altering/config/server"
        "github.com/igortoigildin/go-metrics-altering/internal/models"
        local "github.com/igortoigildin/go-metrics-altering/internal/storage/inmemory"
        psql "github.com/igortoigildin/go-metrics-altering/internal/storage/postgres"
        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
        "go.uber.org/zap"
)

//go:generate go run github.com/vektra/mockery/v2@v2.45.0 --name=Storage
type Storage interface {
        Update(ctx context.Context, metricType string, metricName string, metricValue any) error
        Get(ctx context.Context, metricType string, metricName string) (models.Metrics, error)
        GetAll(ctx context.Context) (map[string]any, error)
        Ping(ctx context.Context) error
}

func New(cfg *config.ConfigServer) Storage <span class="cov8" title="1">{
        if cfg.FlagDBDSN != "" </span><span class="cov0" title="0">{
                storage := psql.New(cfg)
                return storage
        }</span>

        <span class="cov8" title="1">memory := local.New()

        if cfg.FlagRestore </span><span class="cov0" title="0">{
                err := memory.LoadMetricsFromFile(cfg.FlagStorePath)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error loading metrics from the file", zap.Error(err))
                }</span>
        }
        <span class="cov8" title="1">if cfg.FlagStorePath != "" </span><span class="cov8" title="1">{
                go memory.SaveAllMetricsToFile(cfg.FlagStoreInterval, cfg.FlagStorePath, cfg.FlagStorePath)
        }</span>
        <span class="cov8" title="1">return memory</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package crypt

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
)

func Decrypt(privateKeyPEM []byte, input []byte) ([]byte, error) <span class="cov8" title="1">{

        privateKeyBlock, _ := pem.Decode(privateKeyPEM)
        privateKey, err := x509.ParsePKCS1PrivateKey(privateKeyBlock.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">res, err := rsa.DecryptPKCS1v15(rand.Reader, privateKey, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return res, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package crypt

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
)

func Encrypt(publicKeyPEM []byte, msg []byte) ([]byte, error) <span class="cov8" title="1">{
        publicKeyBlock, _ := pem.Decode(publicKeyPEM)
        publicKey, err := x509.ParsePKIXPublicKey(publicKeyBlock.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ciphertext, err := rsa.EncryptPKCS1v15(rand.Reader, publicKey.(*rsa.PublicKey), msg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return ciphertext, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package crypt

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "io/fs"
        "os"

        config "github.com/igortoigildin/go-metrics-altering/config/server"
)

const (
        publicKey  = "public.pem"
        privateKey = "private.pem"
        keysDir    = "keys"
)

func InitRSAKeys(cfg *config.ConfigServer) error <span class="cov8" title="1">{
        privateKeyPEM, publicKeyPEM, err := GenerateRSAKeys(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = os.MkdirAll("keys", 0777)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = saveKey("/"+privateKey, privateKeyPEM, 0777)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = saveKey("/"+publicKey, publicKeyPEM, 0777)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// InitRSAKeys generates and saves private and public rsa keys.
func GenerateRSAKeys(cfg *config.ConfigServer) ([]byte, []byte, error) <span class="cov8" title="1">{
        privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">publicKey := &amp;privateKey.PublicKey

        privateKeyBytes := x509.MarshalPKCS1PrivateKey(privateKey)

        privateKeyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: privateKeyBytes,
        })

        publicKeyBytes, err := x509.MarshalPKIXPublicKey(publicKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">publicKeyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "RSA PUBLIC KEY",
                Bytes: publicKeyBytes,
        })

        return privateKeyPEM, publicKeyPEM, nil</span>
}

func saveKey(name string, data []byte, perm fs.FileMode) error <span class="cov8" title="1">{
        err := os.WriteFile(keysDir+name, data, perm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package httpserver

import (
        "time"
)

// Option -.
type Option func(*Server)

// Port -.
func Address(address string) (Option, error) <span class="cov8" title="1">{
        return func(s *Server) </span><span class="cov0" title="0">{
                s.server.Addr = address
        }</span>, nil
}

// ReadTimeout -.
func ReadTimeout(timeout time.Duration) (Option, error) <span class="cov8" title="1">{
        return func(s *Server) </span><span class="cov0" title="0">{
                s.server.ReadTimeout = timeout
        }</span>, nil
}

// WriteTimeout -.
func WriteTimeout(timeout time.Duration) (Option, error) <span class="cov8" title="1">{
        return func(s *Server) </span><span class="cov0" title="0">{
                s.server.WriteTimeout = timeout
        }</span>, nil
}

// ShutdownTimeout -.
func ShutdownTimeout(timeout time.Duration) (Option, error) <span class="cov8" title="1">{
        return func(s *Server) </span><span class="cov0" title="0">{
                s.ShutdownTimeout = timeout
        }</span>, nil
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package httpserver

import (
        "context"
        "net/http"
        "time"
)

const (
        _defaultReadTimeout     = 5 * time.Second
        _defaultWriteTimeout    = 5 * time.Second
        _defaultAddr            = ":80"
        _defaultShutdownTimeout = 3 * time.Second
)

// Server -.
type Server struct {
        server          *http.Server
        notify          chan error
        ShutdownTimeout time.Duration
}

// New -.
func New(handler http.Handler, opts ...Option) *Server <span class="cov8" title="1">{
        httpServer := &amp;http.Server{
                Handler:      handler,
                ReadTimeout:  _defaultReadTimeout,
                WriteTimeout: _defaultWriteTimeout,
                Addr:         _defaultAddr,
        }

        s := &amp;Server{
                server:          httpServer,
                notify:          make(chan error, 1),
                ShutdownTimeout: _defaultShutdownTimeout,
        }

        // Custom options
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(s)
        }</span>

        <span class="cov8" title="1">s.start()

        return s</span>
}

func (s *Server) start() <span class="cov8" title="1">{
        go func() </span><span class="cov8" title="1">{
                s.notify &lt;- s.server.ListenAndServe()
                close(s.notify)
        }</span>()
}

// Notify -.
func (s *Server) Notify() &lt;-chan error <span class="cov0" title="0">{
        return s.notify
}</span>

// GracefulShutdown -.
func (s *Server) GracefulShutdown() error <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), s.ShutdownTimeout)
        defer cancel()

        return s.server.Shutdown(ctx)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package logger

import "go.uber.org/zap"

var Log *zap.Logger = zap.NewNop()

func Initialize(level string) error <span class="cov8" title="1">{
        lvl, err := zap.ParseAtomicLevel(level)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">cfg := zap.NewProductionConfig()
        cfg.Level = lvl
        zl, err := cfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">Log = zl
        return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package auth provides middleware for basic authorization.
package auth

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
)

// ValidMAC reports whether messageMAC is a valid HMAC tag for message.
func ValidMAC(message, messageMAC, key []byte) (bool, error) <span class="cov8" title="1">{
        mac := hmac.New(sha256.New, key)
        mac.Write([]byte(message))
        expectedMAC := hex.EncodeToString(mac.Sum(nil))
        return hmac.Equal(messageMAC, []byte(expectedMAC)), nil
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">// Package compress provides middleware for request compression.
package compress

import (
        "compress/gzip"
        "io"
        "net/http"
        "strings"
)

type compressWriter struct {
        w  http.ResponseWriter
        zw *gzip.Writer
}

func newCompressWriter(w http.ResponseWriter) *compressWriter <span class="cov8" title="1">{
        return &amp;compressWriter{
                w:  w,
                zw: gzip.NewWriter(w),
        }
}</span>

func (c *compressWriter) Header() http.Header <span class="cov8" title="1">{
        return c.w.Header()
}</span>

func (c *compressWriter) Write(p []byte) (int, error) <span class="cov8" title="1">{
        return c.zw.Write(p)
}</span>

func (c *compressWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        if statusCode &lt; 300 </span><span class="cov0" title="0">{
                c.w.Header().Set("Content-Encoding", "gzip")
        }</span>
        <span class="cov0" title="0">c.w.WriteHeader(statusCode)</span>
}

func (c *compressWriter) Close() error <span class="cov8" title="1">{
        return c.zw.Close()
}</span>

type compressReader struct {
        r  io.ReadCloser
        zr *gzip.Reader
}

func newCompressReader(r io.ReadCloser) (*compressReader, error) <span class="cov8" title="1">{
        zr, err := gzip.NewReader(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;compressReader{
                r:  r,
                zr: zr,
        }, nil</span>
}

func (c compressReader) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        return c.zr.Read(p)
}</span>

func (c *compressReader) Close() error <span class="cov8" title="1">{
        if err := c.r.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return c.zr.Close()</span>
}

func GzipMiddleware(h http.HandlerFunc) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ow := w
                acceptEncoding := r.Header.Get("Accept-Encoding")
                supportsGzip := strings.Contains(acceptEncoding, "gzip")
                if supportsGzip </span><span class="cov8" title="1">{
                        cw := newCompressWriter(w)
                        ow = cw
                        defer cw.Close()
                }</span>
                <span class="cov8" title="1">contentEncoding := r.Header.Get("Content-Encoding")
                sendsGzip := strings.Contains(contentEncoding, "gzip")
                if sendsGzip </span><span class="cov8" title="1">{
                        cr, err := newCompressReader(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov8" title="1">r.Body = cr
                        defer cr.Close()</span>
                }
                <span class="cov8" title="1">h.ServeHTTP(ow, r)</span>
        }
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Package logging provides middleware for logging http requests and responses.

package logging

import (
        "net/http"
        "time"

        "github.com/igortoigildin/go-metrics-altering/pkg/logger"

        "go.uber.org/zap"
)

type (
        // info struct in regards to reply
        responseData struct {
                status int
                size   int
        }
        loggingResponseWriter struct {
                http.ResponseWriter
                responseData *responseData
        }
)

func (r *loggingResponseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        size, err := r.ResponseWriter.Write(b)
        r.responseData.size += size
        return size, err
}</span>

func (r *loggingResponseWriter) WriteHeader(statusCode int) <span class="cov8" title="1">{
        r.ResponseWriter.WriteHeader(statusCode)
        r.responseData.status = statusCode
}</span>

// WithLogging adds code to regester info regarding request and returns new http.Handler
func WithLogging(h http.Handler) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                start := time.Now()
                responseData := &amp;responseData{
                        status: 0,
                        size:   0,
                }
                lw := loggingResponseWriter{
                        ResponseWriter: w, //using original http.ResponseWriter
                        responseData:   responseData,
                }
                h.ServeHTTP(&amp;lw, r) //using updated http.ResponseWriter
                duration := time.Since(start)
                logger.Log.Info("got incoming HTTP request",
                        zap.String("uri", r.RequestURI),
                        zap.String("method", r.Method),
                        zap.Int("status", responseData.status),
                        zap.String("duration", duration.String()),
                        zap.Int("size", responseData.size),
                )
        }</span>)
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Package timeout provides middleware for adding context with timeout to  http request.
package timeout

import (
        "context"
        "net/http"
        "time"

        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
)

func Timeout(timeout time.Duration, next http.HandlerFunc) http.HandlerFunc <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(r.Context(), timeout)
                defer cancel()

                r = r.WithContext(ctx)

                processDone := make(chan bool)
                go func() </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        processDone &lt;- true
                }</span>()

                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Log.Info("HTTP Request timed out")
                        w.WriteHeader(http.StatusRequestTimeout)
                        w.Write([]byte("timed out"))</span>
                case &lt;-processDone:<span class="cov0" title="0"></span>
                }
        })
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Package processjson provides helpful functions for reading and writing JSON requests.
package processjson

import (
        "encoding/json"
        "net/http"

        "github.com/igortoigildin/go-metrics-altering/pkg/logger"
        "go.uber.org/zap"
)

type ErrorResponse struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}

func SendJSONError(w http.ResponseWriter, code int, message string) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(code)
        json.NewEncoder(w).Encode(ErrorResponse{Code: code, Message: message})
}</span>

func ReadJSON(r *http.Request, dst any) error <span class="cov8" title="1">{
        err := json.NewDecoder(r.Body).Decode(&amp;dst)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error: ", zap.Error(err))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func WriteJSON(rw http.ResponseWriter, status int, data any, headers http.Header) error <span class="cov8" title="1">{
        js, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">js = append(js, '\n')
        for key, value := range headers </span><span class="cov0" title="0">{
                rw.Header()[key] = value
        }</span>

        <span class="cov8" title="1">rw.Header().Set("Content-Type", "application/json")
        rw.WriteHeader(status)
        rw.Write(js)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Package processmap provides helpful function for combination of two maps.
package processmap

func ConvertToSingleMap(a map[string]float64, b map[string]int64) map[string]interface{} <span class="cov8" title="1">{
        c := make(map[string]interface{}, 33)
        for i, v := range a </span><span class="cov8" title="1">{
                c[i] = v
        }</span>
        <span class="cov8" title="1">for j, l := range b </span><span class="cov8" title="1">{
                c[j] = l
        }</span>
        <span class="cov8" title="1">return c</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package templates

import (
        "embed"
        "log"
        "text/template"
)

//go:embed home.gohtml
var FS embed.FS

func ParseTemplate() *template.Template <span class="cov8" title="1">{
        t, err := template.ParseFS(FS, "home.gohtml")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov8" title="1">return t</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
